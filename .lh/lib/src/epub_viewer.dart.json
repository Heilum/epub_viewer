{
    "sourceFile": "lib/src/epub_viewer.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1763178965423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1763178971952,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -202,8 +202,9 @@\n         Factory<HorizontalDragGestureRecognizer>(\n           () => HorizontalDragGestureRecognizer(),\n         ),\n       );\n+      debugPrint('允许横向拖动 added');\n     }\n \n     return recognizers;\n   }\n"
                },
                {
                    "date": 1763184500565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -166,50 +166,8 @@\n   void initState() {\n     super.initState();\n   }\n \n-  /// Build gesture recognizers for the underlying [InAppWebView].\n-  ///\n-  /// - 在滚动模式或垂直分页时，允许垂直拖动（向上/向下滑动）。\n-  /// - 在分页 + 横向轴时，允许水平拖动（左右翻页）。\n-  /// - 始终允许长按，用于文本选择等长按行为。\n-  Set<Factory<OneSequenceGestureRecognizer>> _buildGestureRecognizers() {\n-    final displaySettings = widget.displaySettings ?? EpubDisplaySettings();\n-    final flow = displaySettings.flow;\n-    final axis = displaySettings.axis;\n-\n-    final recognizers = <Factory<OneSequenceGestureRecognizer>>{\n-      Factory<LongPressGestureRecognizer>(\n-        () => LongPressGestureRecognizer(\n-          duration: const Duration(milliseconds: 30),\n-        ),\n-      ),\n-    };\n-\n-    // 垂直滚动或垂直分页：需要纵向拖动交给 WebView\n-    if (flow == EpubFlow.scrolled || axis == EpubAxis.vertical) {\n-      recognizers.add(\n-        Factory<VerticalDragGestureRecognizer>(\n-          () => VerticalDragGestureRecognizer(),\n-        ),\n-      );\n-\n-      debugPrint('允许纵向拖动 added');\n-    }\n-\n-    // 分页 + 横向轴：需要左右滑动交给 WebView 做翻页\n-    if (flow == EpubFlow.paginated && axis == EpubAxis.horizontal) {\n-      recognizers.add(\n-        Factory<HorizontalDragGestureRecognizer>(\n-          () => HorizontalDragGestureRecognizer(),\n-        ),\n-      );\n-      debugPrint('允许横向拖动 added');\n-    }\n-\n-    return recognizers;\n-  }\n-\n   void _handleSelection({\n     required Map<String, dynamic>? rect,\n     required String selectedText,\n     required String cfi,\n@@ -460,9 +418,18 @@\n           if (kDebugMode) {\n             debugPrint(\"JS_LOG: ${consoleMessage.message}\");\n           }\n         },\n-        gestureRecognizers: _buildGestureRecognizers(),\n+        gestureRecognizers: {\n+          Factory<VerticalDragGestureRecognizer>(\n+            () => VerticalDragGestureRecognizer(),\n+          ),\n+          Factory<LongPressGestureRecognizer>(\n+            () => LongPressGestureRecognizer(\n+              duration: const Duration(milliseconds: 30),\n+            ),\n+          ),\n+        },\n       ),\n     );\n   }\n \n"
                },
                {
                    "date": 1763184680417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -166,8 +166,50 @@\n   void initState() {\n     super.initState();\n   }\n \n+  /// Build gesture recognizers for the underlying [InAppWebView].\n+  ///\n+  /// - 在滚动模式或垂直分页时，允许垂直拖动（向上/向下滑动）。\n+  /// - 在分页 + 横向轴时，允许水平拖动（左右翻页）。\n+  /// - 始终允许长按，用于文本选择等长按行为。\n+  Set<Factory<OneSequenceGestureRecognizer>> _buildGestureRecognizers() {\n+    final displaySettings = widget.displaySettings ?? EpubDisplaySettings();\n+    final flow = displaySettings.flow;\n+    final axis = displaySettings.axis;\n+\n+    final recognizers = <Factory<OneSequenceGestureRecognizer>>{\n+      Factory<LongPressGestureRecognizer>(\n+        () => LongPressGestureRecognizer(\n+          duration: const Duration(milliseconds: 30),\n+        ),\n+      ),\n+    };\n+\n+    // 垂直滚动或垂直分页：需要纵向拖动交给 WebView\n+    if (flow == EpubFlow.scrolled || axis == EpubAxis.vertical) {\n+      recognizers.add(\n+        Factory<VerticalDragGestureRecognizer>(\n+          () => VerticalDragGestureRecognizer(),\n+        ),\n+      );\n+\n+      debugPrint('允许纵向拖动 added');\n+    }\n+\n+    // 分页 + 横向轴：需要左右滑动交给 WebView 做翻页\n+    if (flow == EpubFlow.paginated && axis == EpubAxis.horizontal) {\n+      recognizers.add(\n+        Factory<HorizontalDragGestureRecognizer>(\n+          () => HorizontalDragGestureRecognizer(),\n+        ),\n+      );\n+      debugPrint('允许横向拖动 added');\n+    }\n+\n+    return recognizers;\n+  }\n+\n   void _handleSelection({\n     required Map<String, dynamic>? rect,\n     required String selectedText,\n     required String cfi,\n@@ -359,11 +401,24 @@\n         widget.displaySettings?.defaultDirection.name ??\n         EpubDefaultDirection.ltr.name;\n     int fontSize = displaySettings.fontSize;\n \n-    bool useCustomSwipe =\n-        Platform.isAndroid && !displaySettings.useSnapAnimationAndroid;\n+    // Enable custom swipe handling when:\n+    // - Using paginated flow with horizontal axis (typical ebook reading),\n+    //   so左右滑动能触发翻页；并且不依赖平台，iOS 也开启。\n+    // - Or on Android when snap animation is disabled (保持原有行为).\n+    final isPaginatedHorizontal =\n+        displaySettings.flow == EpubFlow.paginated &&\n+        displaySettings.axis == EpubAxis.horizontal;\n \n+    bool useCustomSwipe;\n+    if (isPaginatedHorizontal) {\n+      useCustomSwipe = true;\n+    } else {\n+      useCustomSwipe =\n+          Platform.isAndroid && !displaySettings.useSnapAnimationAndroid;\n+    }\n+\n     String? foregroundColor = widget.displaySettings?.theme?.foregroundColor\n         ?.toHex();\n \n     bool clearSelectionOnPageChange = widget.clearSelectionOnPageChange;\n@@ -418,18 +473,9 @@\n           if (kDebugMode) {\n             debugPrint(\"JS_LOG: ${consoleMessage.message}\");\n           }\n         },\n-        gestureRecognizers: {\n-          Factory<VerticalDragGestureRecognizer>(\n-            () => VerticalDragGestureRecognizer(),\n-          ),\n-          Factory<LongPressGestureRecognizer>(\n-            () => LongPressGestureRecognizer(\n-              duration: const Duration(milliseconds: 30),\n-            ),\n-          ),\n-        },\n+        gestureRecognizers: _buildGestureRecognizers(),\n       ),\n     );\n   }\n \n"
                },
                {
                    "date": 1763213283244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -223,9 +223,9 @@\n       final webViewSize = renderBox.size;\n \n       if (rect == null) {\n         // Still call onTextSelected for basic selection functionality\n-        widget.onTextSelected?.call(\n+        widget.onSelectionEnd ?.call(\n           EpubTextSelection(selectedText: selectedText, selectionCfi: cfi),\n         );\n         return;\n       }\n"
                },
                {
                    "date": 1763213432142,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,10 +21,9 @@\n typedef EpubSelectionCallback =\n     void Function(\n       String selectedText,\n       String cfiRange,\n-      Rect selectionRect,\n-      Rect viewRect,\n+      Rect selectionRect\n     );\n \n class EpubViewer extends StatefulWidget {\n   const EpubViewer({\n@@ -223,9 +222,9 @@\n       final webViewSize = renderBox.size;\n \n       if (rect == null) {\n         // Still call onTextSelected for basic selection functionality\n-        widget.onSelectionEnd?.call(\n+        widget.onSelectionEnd ?.call(\n           EpubTextSelection(selectedText: selectedText, selectionCfi: cfi),\n         );\n         return;\n       }\n"
                },
                {
                    "date": 1763213460879,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -219,9 +219,11 @@\n \n       if (rect == null) {\n         // Still call onTextSelected for basic selection functionality\n         widget.onSelectionEnd?.call(\n-          EpubTextSelection(selectedText: selectedText, selectionCfi: cfi),\n+          selectedText,\n+          cfi,\n+          rect,\n         );\n         return;\n       }\n \n"
                }
            ],
            "date": 1763178965423,
            "name": "Commit-0",
            "content": "import 'dart:io';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_inappwebview/flutter_inappwebview.dart';\n\nimport '../flutter_epub_viewer.dart';\nimport 'utils.dart';\n\n/// Callback for text selection events with WebView-relative coordinates.\n///\n/// Provides precise positioning information for implementing custom selection UI.\n/// All rectangles are relative to the WebView's coordinate system (not screen coordinates).\n///\n/// Parameters:\n/// * [selectedText] - The text that was selected\n/// * [cfiRange] - The EPUB CFI (Canonical Fragment Identifier) range for the selection\n/// * [selectionRect] - The bounding rectangle of the selected text (WebView-relative)\n/// * [viewRect] - The bounding rectangle of the entire WebView\ntypedef EpubSelectionCallback =\n    void Function(\n      String selectedText,\n      String cfiRange,\n      Rect selectionRect,\n      Rect viewRect,\n    );\n\nclass EpubViewer extends StatefulWidget {\n  const EpubViewer({\n    super.key,\n    required this.epubController,\n    required this.epubSource,\n    this.initialCfi,\n    this.onChaptersLoaded,\n    this.onEpubLoaded,\n    this.onLocationLoaded,\n    this.onRelocated,\n    this.onTextSelected,\n    this.displaySettings,\n    this.selectionContextMenu,\n    this.onAnnotationClicked,\n    this.onSelection,\n    this.onSelectionChanging,\n    this.onDeselection,\n    this.suppressNativeContextMenu = false,\n    this.clearSelectionOnPageChange = true,\n  });\n\n  //Epub controller to manage epub\n  final EpubController epubController;\n\n  ///Epub source, accepts url, file or assets\n  ///opf format is not tested, use with caution\n  final EpubSource epubSource;\n\n  ///Initial cfi string to  specify which part of epub to load initially\n  ///if null, the first chapter will be loaded\n  final String? initialCfi;\n\n  ///Call back when epub is loaded and displayed\n  final VoidCallback? onEpubLoaded;\n\n  /// Callback when the location are generated for epub, progress will be only available after this\n  final VoidCallback? onLocationLoaded;\n\n  ///Call back when chapters are loaded\n  final ValueChanged<List<EpubChapter>>? onChaptersLoaded;\n\n  ///Call back when epub page changes\n  final ValueChanged<EpubLocation>? onRelocated;\n\n  ///Call back when text selection changes\n  final ValueChanged<EpubTextSelection>? onTextSelected;\n\n  ///initial display settings\n  final EpubDisplaySettings? displaySettings;\n\n  ///Callback for handling annotation click (Highlight and Underline)\n  final ValueChanged<String>? onAnnotationClicked;\n\n  /// Context menu for text selection.\n  /// If null, the default context menu will be used.\n  final ContextMenu? selectionContextMenu;\n\n  /// Whether to suppress the native context menu entirely.\n  /// When true, no native context menu will be shown on text selection.\n  /// Use with [onSelection] to implement custom selection UI.\n  final bool suppressNativeContextMenu;\n\n  /// Callback when text is selected with WebView-relative coordinates.\n  ///\n  /// Fires when:\n  /// * User completes initial text selection\n  /// * User finishes dragging selection handles (after a 300ms debounce)\n  ///\n  /// Use this callback to display custom UI at the selection position.\n  /// Coordinates are relative to the WebView, not the screen.\n  ///\n  /// See also:\n  /// * [onSelectionChanging] - Called while user is actively dragging handles\n  /// * [onDeselection] - Called when selection is cleared\n  final EpubSelectionCallback? onSelection;\n\n  /// Callback fired continuously while the user is dragging selection handles.\n  ///\n  /// This callback helps prevent UI flicker and performance issues by allowing you to\n  /// hide custom selection UI while the user is actively adjusting the selection.\n  /// Once dragging stops, [onSelection] will be called with the final selection.\n  ///\n  /// Typical usage:\n  /// ```dart\n  /// onSelectionChanging: () {\n  ///   // Hide custom selection UI while user drags handles\n  ///   setState(() => showSelectionMenu = false);\n  /// }\n  /// ```\n  ///\n  /// See also:\n  /// * [onSelection] - Called when selection is finalized\n  final VoidCallback? onSelectionChanging;\n\n  /// Callback when text selection is cleared.\n  ///\n  /// Fired when the user taps elsewhere or explicitly clears the selection.\n  /// Use this to hide any custom selection UI.\n  final VoidCallback? onDeselection;\n\n  /// Whether to automatically clear text selection when navigating to a new page.\n  ///\n  /// When true (default), text selection will be cleared when the user navigates\n  /// to a different page using next(), previous(), or toCfi(). This is the standard\n  /// behavior in most e-reader applications.\n  ///\n  /// Set to false if you want to preserve selection across page changes, though\n  /// note that the selection may not be visible on the new page.\n  final bool clearSelectionOnPageChange;\n\n  @override\n  State<EpubViewer> createState() => _EpubViewerState();\n}\n\nclass _EpubViewerState extends State<EpubViewer> {\n  final GlobalKey webViewKey = GlobalKey();\n\n  var selectedText = '';\n\n  InAppWebViewController? webViewController;\n\n  InAppWebViewSettings settings = InAppWebViewSettings(\n    isInspectable: kDebugMode,\n    javaScriptEnabled: true,\n    mediaPlaybackRequiresUserGesture: false,\n    transparentBackground: true,\n    supportZoom: false,\n    allowsInlineMediaPlayback: true,\n    disableLongPressContextMenuOnLinks: true,\n    iframeAllowFullscreen: true,\n    allowsLinkPreview: false,\n    verticalScrollBarEnabled: false,\n    selectionGranularity: SelectionGranularity.CHARACTER,\n    disableContextMenu: true, // Disable native context menu\n  );\n\n  @override\n  void initState() {\n    super.initState();\n  }\n\n  /// Build gesture recognizers for the underlying [InAppWebView].\n  ///\n  /// - 在滚动模式或垂直分页时，允许垂直拖动（向上/向下滑动）。\n  /// - 在分页 + 横向轴时，允许水平拖动（左右翻页）。\n  /// - 始终允许长按，用于文本选择等长按行为。\n  Set<Factory<OneSequenceGestureRecognizer>> _buildGestureRecognizers() {\n    final displaySettings = widget.displaySettings ?? EpubDisplaySettings();\n    final flow = displaySettings.flow;\n    final axis = displaySettings.axis;\n\n    final recognizers = <Factory<OneSequenceGestureRecognizer>>{\n      Factory<LongPressGestureRecognizer>(\n        () => LongPressGestureRecognizer(\n          duration: const Duration(milliseconds: 30),\n        ),\n      ),\n    };\n\n    // 垂直滚动或垂直分页：需要纵向拖动交给 WebView\n    if (flow == EpubFlow.scrolled || axis == EpubAxis.vertical) {\n      recognizers.add(\n        Factory<VerticalDragGestureRecognizer>(\n          () => VerticalDragGestureRecognizer(),\n        ),\n      );\n\n      debugPrint('允许纵向拖动 added');\n    }\n\n    // 分页 + 横向轴：需要左右滑动交给 WebView 做翻页\n    if (flow == EpubFlow.paginated && axis == EpubAxis.horizontal) {\n      recognizers.add(\n        Factory<HorizontalDragGestureRecognizer>(\n          () => HorizontalDragGestureRecognizer(),\n        ),\n      );\n    }\n\n    return recognizers;\n  }\n\n  void _handleSelection({\n    required Map<String, dynamic>? rect,\n    required String selectedText,\n    required String cfi,\n  }) {\n    if (!mounted) return;\n\n    try {\n      final renderBox = context.findRenderObject() as RenderBox;\n      final webViewSize = renderBox.size;\n\n      if (rect == null) {\n        // Still call onTextSelected for basic selection functionality\n        widget.onTextSelected?.call(\n          EpubTextSelection(selectedText: selectedText, selectionCfi: cfi),\n        );\n        return;\n      }\n\n      // Convert relative coordinates (0-1) to actual WebView coordinates\n      final left = (rect['left'] as num).toDouble();\n      final top = (rect['top'] as num).toDouble();\n      final width = (rect['width'] as num).toDouble();\n      final height = (rect['height'] as num).toDouble();\n\n      final scaledRect = Rect.fromLTWH(\n        left * webViewSize.width,\n        top * webViewSize.height,\n        width * webViewSize.width,\n        height * webViewSize.height,\n      );\n\n      // Create viewRect in WebView-relative coordinates\n      final viewRect = Rect.fromLTWH(\n        0,\n        0,\n        webViewSize.width,\n        webViewSize.height,\n      );\n\n      // Provide WebView-relative coordinates (not screen coordinates)\n      widget.onSelection?.call(\n        selectedText,\n        cfi,\n        scaledRect, // WebView-relative coordinates\n        viewRect,\n      );\n    } catch (e) {\n      if (kDebugMode) {\n        debugPrint(\"Error in _handleSelection: $e\");\n      }\n    }\n  }\n\n  void addJavaScriptHandlers() {\n    webViewController?.addJavaScriptHandler(\n      handlerName: \"displayed\",\n      callback: (data) {\n        widget.onEpubLoaded?.call();\n      },\n    );\n\n    webViewController?.addJavaScriptHandler(\n      handlerName: \"chapters\",\n      callback: (data) async {\n        final chapters = await widget.epubController.parseChapters();\n        widget.onChaptersLoaded?.call(chapters);\n      },\n    );\n\n    webViewController?.addJavaScriptHandler(\n      handlerName: \"selection\",\n      callback: (data) {\n        final cfiString = data[0] as String;\n        final selectedText = data[1] as String;\n        Map<String, dynamic>? rect;\n\n        try {\n          if (data.length > 2 && data[2] != null) {\n            rect = Map<String, dynamic>.from(data[2] as Map);\n          }\n        } catch (e) {\n          if (kDebugMode) {\n            debugPrint('Error parsing selection rect: $e');\n          }\n          rect = null;\n        }\n\n        // Always call basic text selection callback\n        widget.onTextSelected?.call(\n          EpubTextSelection(\n            selectedText: selectedText,\n            selectionCfi: cfiString,\n          ),\n        );\n\n        // If we have coordinates and a selection callback, provide full selection info\n        if (rect != null && widget.onSelection != null) {\n          _handleSelection(\n            rect: rect,\n            selectedText: selectedText,\n            cfi: cfiString,\n          );\n        }\n      },\n    );\n\n    // Add deselection handler\n    webViewController?.addJavaScriptHandler(\n      handlerName: 'selectionCleared',\n      callback: (args) {\n        widget.onDeselection?.call();\n      },\n    );\n\n    // Add selection changing handler (dragging handles)\n    webViewController?.addJavaScriptHandler(\n      handlerName: 'selectionChanging',\n      callback: (args) {\n        widget.onSelectionChanging?.call();\n      },\n    );\n\n    webViewController?.addJavaScriptHandler(\n      handlerName: \"search\",\n      callback: (data) async {\n        var searchResult = data[0];\n        widget.epubController.searchResultCompleter.complete(\n          List<EpubSearchResult>.from(\n            searchResult.map((e) => EpubSearchResult.fromJson(e)),\n          ),\n        );\n      },\n    );\n\n    webViewController?.addJavaScriptHandler(\n      handlerName: \"relocated\",\n      callback: (data) {\n        var location = data[0];\n        widget.onRelocated?.call(EpubLocation.fromJson(location));\n      },\n    );\n\n    webViewController?.addJavaScriptHandler(\n      handlerName: 'locationLoaded',\n      callback: (arguments) {\n        widget.onLocationLoaded?.call();\n      },\n    );\n\n    webViewController?.addJavaScriptHandler(\n      handlerName: \"readyToLoad\",\n      callback: (data) {\n        loadBook();\n      },\n    );\n\n    webViewController?.addJavaScriptHandler(\n      handlerName: \"markClicked\",\n      callback: (data) {\n        String cfi = data[0];\n        widget.onAnnotationClicked?.call(cfi);\n      },\n    );\n\n    webViewController?.addJavaScriptHandler(\n      handlerName: \"epubText\",\n      callback: (data) {\n        var text = data[0].trim();\n        var cfi = data[1];\n        widget.epubController.pageTextCompleter.complete(\n          EpubTextExtractRes(text: text, cfiRange: cfi),\n        );\n      },\n    );\n  }\n\n  Future<void> loadBook() async {\n    var data = await widget.epubSource.epubData;\n    final displaySettings = widget.displaySettings ?? EpubDisplaySettings();\n    String manager = displaySettings.manager.name;\n    String flow = displaySettings.flow.name;\n    String spread = displaySettings.spread.name;\n    String axis = displaySettings.axis.name;\n    // Snap only works in paginated mode, force false for scrolled mode\n    bool snap = flow == 'paginated' ? displaySettings.snap : false;\n    bool allowScripted = displaySettings.allowScriptedContent;\n    String cfi = widget.initialCfi ?? \"\";\n    String direction =\n        widget.displaySettings?.defaultDirection.name ??\n        EpubDefaultDirection.ltr.name;\n    int fontSize = displaySettings.fontSize;\n\n    bool useCustomSwipe =\n        Platform.isAndroid && !displaySettings.useSnapAnimationAndroid;\n\n    String? foregroundColor = widget.displaySettings?.theme?.foregroundColor\n        ?.toHex();\n\n    bool clearSelectionOnPageChange = widget.clearSelectionOnPageChange;\n\n    webViewController?.evaluateJavascript(\n      source:\n          'loadBook([${data.join(',')}], \"$cfi\", \"$manager\", \"$flow\", \"$spread\", $snap, $allowScripted, \"$direction\", $useCustomSwipe, \"${null}\", \"$foregroundColor\", \"$fontSize\", $clearSelectionOnPageChange, \"$axis\")',\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      decoration: widget.displaySettings?.theme?.backgroundDecoration,\n      child: InAppWebView(\n        contextMenu: widget.suppressNativeContextMenu\n            ? ContextMenu(\n                menuItems: [],\n                settings: ContextMenuSettings(\n                  hideDefaultSystemContextMenuItems: true,\n                ),\n                onCreateContextMenu: (hitTestResult) async {\n                  // Completely disable context menu\n                },\n              )\n            : widget.selectionContextMenu,\n        key: webViewKey,\n        initialFile:\n            'packages/flutter_epub_viewer/lib/assets/webpage/html/swipe.html',\n        initialSettings: settings\n          ..disableVerticalScroll = widget.displaySettings?.snap ?? false,\n        onWebViewCreated: (controller) async {\n          webViewController = controller;\n          widget.epubController.setWebViewController(controller);\n          addJavaScriptHandlers();\n        },\n        onLoadStart: (controller, url) {},\n        onPermissionRequest: (controller, request) async {\n          return PermissionResponse(\n            resources: request.resources,\n            action: PermissionResponseAction.GRANT,\n          );\n        },\n        shouldOverrideUrlLoading: (controller, navigationAction) async {\n          return NavigationActionPolicy.ALLOW;\n        },\n        onLoadStop: (controller, url) async {},\n        onReceivedError: (controller, request, error) {},\n        onProgressChanged: (controller, progress) {},\n        onUpdateVisitedHistory: (controller, url, androidIsReload) {},\n        onConsoleMessage: (controller, consoleMessage) {\n          if (kDebugMode) {\n            debugPrint(\"JS_LOG: ${consoleMessage.message}\");\n          }\n        },\n        gestureRecognizers: _buildGestureRecognizers(),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    webViewController?.dispose();\n    super.dispose();\n  }\n}\n"
        }
    ]
}