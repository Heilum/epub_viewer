{
    "sourceFile": "lib/assets/webpage/html/original_epub.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1763174799058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1763174799058,
            "name": "Commit-0",
            "content": "var book = ePub();\nvar rendition;\nvar displayed;\nvar chapters = []\nvar clearSelectionOnPageChange = true; // Global flag for selection clearing behavior\nvar initialXPathProcessed = false; // Flag to prevent processing initialXPath multiple times\nvar xpathDisplayInProgress = false; // Flag to prevent multiple XPath displays\nvar initialPositionLoading = false; // Flag to track if initial position is being loaded\n// Global selection state tracking (needed for blocking navigation when selection is active)\nvar isSelecting = false;\nvar lastCfiRange = null;\nvar selectionTimeout = null;\nvar hasSentSelection = false; // Track if we've actually sent a selection event to Flutter\nvar lastTapCoords = null; // Store the last tap coordinates for onTouchDown/onTouchUp callbacks\n\nfunction loadBook(data, cfi, initialXPath, manager, flow, spread, snap, allowScriptedContent, direction, useCustomSwipe, backgroundColor, foregroundColor, fontSize, clearSelectionOnNav) {\n    // Reset flags for new book\n    initialXPathProcessed = false;\n    xpathDisplayInProgress = false;\n    initialPositionLoading = false;\n    // Store the clearSelectionOnPageChange setting\n    clearSelectionOnPageChange = clearSelectionOnNav !== undefined ? clearSelectionOnNav : true;\n    var viewportHeight = window.innerHeight;\n    document.getElementById('viewer').style.height = viewportHeight;\n    var uint8Array = new Uint8Array(data)\n    book.open(uint8Array,)\n    rendition = book.renderTo(\"viewer\", {\n        manager: manager,\n        flow: flow,\n        spread: spread,\n        width: \"100vw\",\n        height: \"100vh\",\n        snap: snap && !useCustomSwipe,\n        allowScriptedContent: allowScriptedContent,\n        defaultDirection: direction\n    });\n\n    // Initial display - skip if we have XPath (we'll display after conversion)\n    // If we have XPath, we'll display after converting it, so skip initial display\n    if (initialXPath) {\n        // Just display the default location, we'll navigate to XPath after conversion\n        displayed = rendition.display()\n        // XPath conversion will happen later in book.ready, callback will be fired there\n    } else if (cfi) {\n        // CFI display happens immediately, so fire callback now\n        initialPositionLoading = true;\n        try {\n            window.flutter_inappwebview.callHandler('initialPositionLoading', { type: 'cfi' });\n        } catch (e) {\n            console.error('Error calling initialPositionLoading callback:', e);\n        }\n        displayed = rendition.display(cfi)\n    } else {\n        displayed = rendition.display()\n    }\n\n    // Setup blocking immediately after rendition is created\n    // Use setTimeout to ensure rendition object is fully initialized\n    setTimeout(function () {\n        setupRenditionBlocking();\n    }, 100);\n\n    rendition.on(\"displayed\", function (renderer) {\n        window.flutter_inappwebview.callHandler('displayed');\n        // If we were loading initial position, notify that it's complete\n        if (initialPositionLoading) {\n            initialPositionLoading = false;\n            try {\n                window.flutter_inappwebview.callHandler('initialPositionLoaded');\n            } catch (e) {\n                console.error('Error calling initialPositionLoaded callback:', e);\n            }\n        }\n        // Setup blocking again to ensure it's active (in case it wasn't set up earlier)\n        setupRenditionBlocking();\n    });\n\n    // Reset selection state tracking (use global variables)\n    selectionTimeout = null;\n    isSelecting = false;\n    lastCfiRange = null;\n    hasSentSelection = false;\n\n    // Helper function to check and process selection\n    function checkAndProcessSelection(contents) {\n        try {\n            // Try contents window first\n            var selection = contents.window.getSelection();\n            var range = null;\n            var selectedText = '';\n\n            if (selection && selection.rangeCount > 0) {\n                try {\n                    range = selection.getRangeAt(0);\n                    selectedText = selection.toString();\n                } catch (e) {\n                    // Ignore errors\n                }\n            }\n\n            // If no selection in contents, try parent window (iPad sometimes puts it there)\n            if ((!selectedText || !range || range.collapsed) && window.getSelection) {\n                try {\n                    var parentSelection = window.getSelection();\n                    if (parentSelection && parentSelection.rangeCount > 0) {\n                        var parentRange = parentSelection.getRangeAt(0);\n                        var parentText = parentSelection.toString();\n                        // Check if parent selection is actually in the epub content\n                        if (parentText && !parentRange.collapsed) {\n                            // Try to find which iframe this selection is in\n                            var iframe = contents.document.defaultView.frameElement;\n                            if (iframe && parentRange.commonAncestorContainer) {\n                                // Check if the selection is within our iframe\n                                try {\n                                    if (iframe.contentDocument &&\n                                        (iframe.contentDocument === parentRange.commonAncestorContainer.ownerDocument ||\n                                            iframe.contentDocument.contains(parentRange.commonAncestorContainer))) {\n                                        selection = parentSelection;\n                                        range = parentRange;\n                                        selectedText = parentText;\n                                    }\n                                } catch (e) {\n                                    // Cross-origin or other error, try anyway\n                                    selection = parentSelection;\n                                    range = parentRange;\n                                    selectedText = parentText;\n                                }\n                            }\n                        }\n                    }\n                } catch (e) {\n                    // Ignore errors\n                }\n            }\n\n            if (!selection || !range || selection.rangeCount === 0) {\n                return false;\n            }\n\n            if (!selectedText || range.collapsed) {\n                return false;\n            }\n\n            // If we already have this selection, don't process again\n            if (isSelecting && lastCfiRange) {\n                return true;\n            }\n\n            // Try to get CFI from range using epub.js API\n            try {\n                if (typeof contents.cfiFromRange === 'function') {\n                    var cfiRange = contents.cfiFromRange(range);\n                    if (cfiRange) {\n                        lastCfiRange = cfiRange;\n                        isSelecting = true;\n                        // Clear any existing timeout\n                        if (selectionTimeout) {\n                            clearTimeout(selectionTimeout);\n                        }\n                        // Debounce to allow selection to stabilize\n                        selectionTimeout = setTimeout(function () {\n                            // Verify selection still exists before sending\n                            var stillHasSelection = false;\n                            try {\n                                var currentSelection = contents.window.getSelection();\n                                if (currentSelection && currentSelection.rangeCount > 0) {\n                                    var currentRange = currentSelection.getRangeAt(0);\n                                    var currentText = currentSelection.toString();\n                                    if (currentText && currentRange && !currentRange.collapsed) {\n                                        stillHasSelection = true;\n                                    }\n                                }\n                            } catch (e) {\n                                // Ignore errors\n                            }\n\n                            if (stillHasSelection && lastCfiRange === cfiRange) {\n                                sendSelectionData(cfiRange, contents);\n                            } else {\n                                // Selection was cleared before timeout fired, clear flags\n                                if (lastCfiRange === cfiRange) {\n                                    isSelecting = false;\n                                    lastCfiRange = null;\n                                    hasSentSelection = false;\n                                }\n                            }\n                        }, 200);\n                        return true;\n                    }\n                }\n            } catch (e) {\n                // Ignore errors\n            }\n        } catch (e) {\n            // Ignore errors\n        }\n        return false;\n    }\n\n    // Continuous polling for iPad (as last resort when events don't fire)\n    var pollIntervals = []; // Store intervals for each content frame\n    var lastPolledSelections = new Map(); // Track last selection per contents\n\n    function startPolling(contents) {\n        // Check if we're already polling this contents\n        var contentsId = contents.document ? contents.document.URL : 'unknown';\n        if (lastPolledSelections.has(contentsId)) {\n            return;\n        }\n\n        lastPolledSelections.set(contentsId, null);\n\n        var pollCount = 0;\n        var noSelectionCount = 0;\n        var interval = setInterval(function () {\n            try {\n                pollCount++;\n\n                // Stop polling if no selection found for 5 seconds (50 polls * 100ms)\n                // This optimizes performance - only poll when there might be a selection\n                if (pollCount > 50 && noSelectionCount > 40) {\n                    clearInterval(interval);\n                    lastPolledSelections.delete(contentsId);\n                    return;\n                }\n\n                // Check if window/selection API is available\n                if (!contents.window || !contents.window.getSelection) {\n                    return;\n                }\n\n                var selection = contents.window.getSelection();\n                if (!selection) {\n                    noSelectionCount++;\n                    return;\n                }\n\n                // Check selection properties even if toString() is empty\n                var rangeCount = selection.rangeCount || 0;\n                var selectedText = selection.toString() || '';\n                var hasRanges = rangeCount > 0;\n\n                // Even if toString() is empty, check if there are ranges (iPad quirk)\n                var currentSelection = selectedText || (hasRanges ? 'HAS_RANGE_BUT_NO_TEXT' : null);\n                var lastSelection = lastPolledSelections.get(contentsId);\n\n                // Only process if selection changed\n                if (currentSelection !== lastSelection) {\n                    lastPolledSelections.set(contentsId, currentSelection);\n                    noSelectionCount = 0; // Reset counter when selection found\n\n                    if (!selectedText && !hasRanges) {\n                        // Clear flags if they're set (even if we haven't sent a selection yet)\n                        if (isSelecting || lastCfiRange) {\n                            // Only fire selectionCleared if we've actually sent a selection\n                            if (hasSentSelection) {\n                                window.flutter_inappwebview.callHandler('selectionCleared');\n                            }\n                            // Always clear the flags when there's no selection\n                            isSelecting = false;\n                            lastCfiRange = null;\n                            hasSentSelection = false;\n                            if (selectionTimeout) {\n                                clearTimeout(selectionTimeout);\n                                selectionTimeout = null;\n                            }\n                        }\n                    } else {\n                        // Selection exists - try to process it\n                        if (!isSelecting) {\n                            checkAndProcessSelection(contents);\n                        }\n                    }\n                } else if (!currentSelection) {\n                    noSelectionCount++;\n                }\n            } catch (e) {\n                // Ignore errors\n            }\n        }, 200); // Check every 200ms\n\n        pollIntervals.push({ contentsId: contentsId, interval: interval });\n    }\n\n    function stopPolling() {\n        pollIntervals.forEach(function (item) {\n            clearInterval(item.interval);\n        });\n        pollIntervals = [];\n        lastPolledSelections.clear();\n    }\n\n    // Handle selection clearing and changes\n    rendition.hooks.content.register(function (contents) {\n        // Listen on document\n        contents.window.document.addEventListener('selectionchange', function () {\n            var selection = contents.window.getSelection();\n            var selectedText = selection.toString();\n\n            // Check if there's actually a range, not just text (more reliable)\n            var hasRange = selection && selection.rangeCount > 0;\n            var hasNonCollapsedRange = false;\n            if (hasRange) {\n                try {\n                    var range = selection.getRangeAt(0);\n                    hasNonCollapsedRange = range && !range.collapsed;\n                } catch (e) {\n                    // Ignore errors\n                }\n            }\n\n            // Only clear selection if there's truly no range AND no text\n            // This prevents clearing when toString() is temporarily empty but range exists\n            if (!hasNonCollapsedRange && !selectedText) {\n                // Double-check across all content frames before clearing\n                var stillHasSelection = false;\n                try {\n                    var allContents = rendition.getContents();\n                    for (var i = 0; i < allContents.length; i++) {\n                        try {\n                            var cont = allContents[i];\n                            if (cont.window && cont.window.getSelection) {\n                                var contSel = cont.window.getSelection();\n                                if (contSel && contSel.rangeCount > 0) {\n                                    var contRange = contSel.getRangeAt(0);\n                                    var contText = contSel.toString();\n                                    if (contText || (contRange && !contRange.collapsed)) {\n                                        stillHasSelection = true;\n                                        break;\n                                    }\n                                }\n                            }\n                        } catch (e) {\n                            // Ignore errors\n                        }\n                    }\n                    // Also check parent window\n                    if (!stillHasSelection && window.getSelection) {\n                        var parentSel = window.getSelection();\n                        if (parentSel && parentSel.rangeCount > 0) {\n                            var parentRange = parentSel.getRangeAt(0);\n                            var parentText = parentSel.toString();\n                            if (parentText || (parentRange && !parentRange.collapsed)) {\n                                stillHasSelection = true;\n                            }\n                        }\n                    }\n                } catch (e) {\n                    // Ignore errors\n                }\n\n                if (!stillHasSelection) {\n                    // Clear flags if they're set (even if we haven't sent a selection yet)\n                    // This handles the case where checkAndProcessSelection set flags but selection was cleared before timeout\n                    if (isSelecting || lastCfiRange) {\n                        // Only fire selectionCleared if we've actually sent a selection\n                        if (hasSentSelection) {\n                            window.flutter_inappwebview.callHandler('selectionCleared');\n                        }\n                        // Always clear the flags when there's no selection\n                        isSelecting = false;\n                        lastCfiRange = null;\n                        hasSentSelection = false;\n                        if (selectionTimeout) {\n                            clearTimeout(selectionTimeout);\n                            selectionTimeout = null;\n                        }\n                    }\n                }\n            } else if (isSelecting) {\n                // Selection is being modified (dragging handles)\n                // Notify Flutter to hide the widget\n                window.flutter_inappwebview.callHandler('selectionChanging');\n\n                // Clear existing timeout\n                if (selectionTimeout) {\n                    clearTimeout(selectionTimeout);\n                }\n\n                // Set timeout to detect when dragging stops\n                selectionTimeout = setTimeout(function () {\n                    // Selection has stabilized, send the final selection\n                    if (lastCfiRange) {\n                        sendSelectionData(lastCfiRange, contents);\n                    }\n                    // Set isSelecting = false, but keep lastCfiRange so hasActiveSelection() still returns true\n                    // This allows navigation to remain blocked while selection is active\n                    isSelecting = false;\n                }, 300); // 300ms debounce\n            } else {\n                // Fallback for iPad/iOS: Detect initial selection when epub.js \"selected\" event doesn't fire\n                checkAndProcessSelection(contents);\n            }\n        });\n\n        // Also listen on window (some browsers fire it there)\n        if (contents.window.addEventListener) {\n            contents.window.addEventListener('selectionchange', function () {\n                var selection = contents.window.getSelection();\n                var selectedText = selection.toString();\n                if (selectedText && !isSelecting) {\n                    checkAndProcessSelection(contents);\n                }\n            });\n        }\n\n        // Start polling for this content frame (optimized - stops if no selection found)\n        try {\n            startPolling(contents);\n        } catch (e) {\n            // Ignore errors\n        }\n\n        // Also try to get all contents and poll them (important for spread layout with 2 pages)\n        try {\n            var allContents = rendition.getContents();\n            allContents.forEach(function (cont, index) {\n                var frameId = cont.document ? cont.document.URL : ('frame' + index);\n                if (cont.window && !lastPolledSelections.has(frameId)) {\n                    startPolling(cont);\n                }\n            });\n\n            // Set up a periodic check to ensure all frames are being polled\n            // (in case frames are added/removed dynamically)\n            setInterval(function () {\n                try {\n                    var currentContents = rendition.getContents();\n                    currentContents.forEach(function (cont, index) {\n                        var frameId = cont.document ? cont.document.URL : ('frame' + index);\n                        if (cont.window && !lastPolledSelections.has(frameId)) {\n                            startPolling(cont);\n                        }\n                    });\n                } catch (e) {\n                    // Ignore errors in periodic check\n                }\n            }, 2000); // Check every 2 seconds for new frames\n        } catch (e) {\n            // Ignore errors\n        }\n\n        // Also poll parent window selection (iPad often puts selection there)\n        if (!lastPolledSelections.has('parent')) {\n            lastPolledSelections.set('parent', null);\n            var parentNoSelectionCount = 0;\n            var parentInterval = setInterval(function () {\n                try {\n                    if (!window.getSelection) return;\n                    var parentSelection = window.getSelection();\n                    var parentText = parentSelection ? parentSelection.toString() : '';\n                    var currentParentSelection = parentText || null;\n                    var lastParentSelection = lastPolledSelections.get('parent');\n\n                    if (currentParentSelection !== lastParentSelection) {\n                        lastPolledSelections.set('parent', currentParentSelection);\n                        parentNoSelectionCount = 0;\n\n                        if (parentText && parentSelection.rangeCount > 0) {\n                            // Try to process with each content frame (important for spread with 2 pages)\n                            try {\n                                var allContents = rendition.getContents();\n                                allContents.forEach(function (cont, index) {\n                                    if (!isSelecting) {\n                                        checkAndProcessSelection(cont);\n                                    }\n                                });\n                            } catch (e) {\n                                // Ignore errors\n                            }\n                        } else {\n                            parentNoSelectionCount++;\n                        }\n                    } else if (!currentParentSelection) {\n                        parentNoSelectionCount++;\n                    }\n\n                    // Stop polling if no selection found for 5 seconds\n                    if (parentNoSelectionCount > 25) {\n                        clearInterval(parentInterval);\n                        lastPolledSelections.delete('parent');\n                    }\n                } catch (e) {\n                    // Ignore errors\n                }\n            }, 200);\n            pollIntervals.push({ contentsId: 'parent', interval: parentInterval });\n        }\n    });\n\n    book.loaded.navigation.then(function (toc) {\n        chapters = parseChapters(toc)\n        window.flutter_inappwebview.callHandler('chapters');\n    })\n\n    rendition.on(\"rendered\", function () {\n        window.flutter_inappwebview.callHandler('rendered');\n    })\n\n    // Function to calculate and send selection data\n    // Make it globally accessible for native callbacks (needed for iPad support)\n    function sendSelectionData(cfiRange, contents) {\n        book.getRange(cfiRange).then(function (range) {\n            var selectedText = range.toString();\n\n            // Convert CFI to XPath\n            cfiRangeToXPath(cfiRange.toString()).then(function (selectionXpath) {\n                try {\n                    // Get selection coordinates\n                    var selection = contents.window.getSelection();\n                    var rect = null;\n\n                    if (selection && selection.rangeCount > 0) {\n                        // Get the range and its client rect (relative to iframe viewport)\n                        var selRange = selection.getRangeAt(0);\n                        var clientRect = selRange.getBoundingClientRect();\n\n                        // Get the WebView dimensions (parent window)\n                        var webViewWidth = window.innerWidth;\n                        var webViewHeight = window.innerHeight;\n\n                        // Get the iframe element in the parent document\n                        var iframe = contents.document.defaultView.frameElement;\n                        var iframeRect = iframe.getBoundingClientRect();\n\n                        // Calculate absolute position in WebView (iframe offset + selection position)\n                        var absoluteLeft = iframeRect.left + clientRect.left;\n                        var absoluteTop = iframeRect.top + clientRect.top;\n\n                        // Normalize to 0-1 range relative to WebView dimensions\n                        rect = {\n                            left: absoluteLeft / webViewWidth,\n                            top: absoluteTop / webViewHeight,\n                            width: clientRect.width / webViewWidth,\n                            height: clientRect.height / webViewHeight,\n                            contentHeight: webViewHeight\n                        };\n                    }\n\n                    var args = [cfiRange.toString(), selectedText, rect, selectionXpath];\n                    window.flutter_inappwebview.callHandler('selection', ...args);\n                    hasSentSelection = true; // Mark that we've sent a selection\n                } catch (e) {\n                    // Still send the selection without coordinates if there's an error\n                    var args = [cfiRange.toString(), selectedText, null, selectionXpath];\n                    window.flutter_inappwebview.callHandler('selection', ...args);\n                    hasSentSelection = true; // Mark that we've sent a selection\n                }\n            }).catch(function (e) {\n                // If XPath conversion fails, still send CFI\n                try {\n                    var selection = contents.window.getSelection();\n                    var rect = null;\n                    if (selection && selection.rangeCount > 0) {\n                        var selRange = selection.getRangeAt(0);\n                        var clientRect = selRange.getBoundingClientRect();\n                        var webViewWidth = window.innerWidth;\n                        var webViewHeight = window.innerHeight;\n                        var iframe = contents.document.defaultView.frameElement;\n                        var iframeRect = iframe.getBoundingClientRect();\n                        var absoluteLeft = iframeRect.left + clientRect.left;\n                        var absoluteTop = iframeRect.top + clientRect.top;\n                        rect = {\n                            left: absoluteLeft / webViewWidth,\n                            top: absoluteTop / webViewHeight,\n                            width: clientRect.width / webViewWidth,\n                            height: clientRect.height / webViewHeight,\n                            contentHeight: webViewHeight\n                        };\n                    } else {\n                        // No rect available\n                    }\n                    var args = [cfiRange.toString(), selectedText, rect, null];\n                    window.flutter_inappwebview.callHandler('selection', ...args);\n                    hasSentSelection = true; // Mark that we've sent a selection\n                } catch (e2) {\n                    var args = [cfiRange.toString(), selectedText, null, null];\n                    window.flutter_inappwebview.callHandler('selection', ...args);\n                    hasSentSelection = true; // Mark that we've sent a selection\n                }\n            });\n        });\n    }\n\n    // Make sendSelectionData globally accessible for iPad native callbacks\n    window.sendSelectionData = sendSelectionData;\n\n    ///text selection callback\n    rendition.on(\"selected\", function (cfiRange, contents) {\n        lastCfiRange = cfiRange;\n\n        if (!isSelecting) {\n            // Initial selection - send immediately\n            isSelecting = true;\n            sendSelectionData(cfiRange, contents);\n        }\n        // If already selecting, the selectionchange handler will debounce it\n    });\n\n    //book location changes callback\n    rendition.on(\"relocated\", function (location) {\n        // BLOCK navigation if there's an active selection\n        // This is a final safeguard - if something bypassed our other blocks, prevent the navigation\n        if (hasActiveSelection()) {\n            console.log('Blocked relocated event - selection active, attempting to revert');\n            // Try to revert to previous location\n            // Store the previous location before blocking\n            if (rendition.location && rendition.location.start) {\n                try {\n                    // Get the current location before this navigation\n                    var currentCfi = rendition.location.start.cfi;\n                    // If we have a stored previous location, go back to it\n                    if (window.lastValidLocation && window.lastValidLocation !== currentCfi) {\n                        console.log('Reverting to last valid location:', window.lastValidLocation);\n                        setTimeout(function () {\n                            if (originalDisplay && !hasActiveSelection()) {\n                                originalDisplay(window.lastValidLocation);\n                            } else if (rendition.display && !hasActiveSelection()) {\n                                rendition.display(window.lastValidLocation);\n                            }\n                        }, 10);\n                    }\n                } catch (e) {\n                    console.error('Error reverting location:', e);\n                }\n            }\n            // Don't process the relocation - return early\n            return;\n        }\n\n        // Store valid location for potential revert\n        if (location && location.start && location.start.cfi) {\n            window.lastValidLocation = location.start.cfi;\n        }\n\n        // Clear selection when navigating to a new page (if enabled)\n        if (clearSelectionOnPageChange && hasSentSelection && (isSelecting || lastCfiRange)) {\n            isSelecting = false;\n            lastCfiRange = null;\n            hasSentSelection = false;\n            if (selectionTimeout) {\n                clearTimeout(selectionTimeout);\n                selectionTimeout = null;\n            }\n\n            // Clear the actual browser selection across all iframe contents\n            rendition.getContents().forEach(function (contents) {\n                try {\n                    if (contents.window.getSelection) {\n                        contents.window.getSelection().removeAllRanges();\n                    }\n                } catch (e) {\n                    // Ignore errors if iframe is not accessible\n                }\n            });\n\n            // Notify Flutter that selection was cleared\n            window.flutter_inappwebview.callHandler('selectionCleared');\n        }\n\n        var percent = location.start.percentage;\n\n        // Convert CFIs to XPath\n        Promise.all([\n            cfiToXPath(location.start.cfi),\n            cfiToXPath(location.end.cfi)\n        ]).then(function (xpaths) {\n            var locationData = {\n                startCfi: location.start.cfi,\n                endCfi: location.end.cfi,\n                startXpath: xpaths[0],\n                endXpath: xpaths[1],\n                progress: percent\n            }\n            var args = [locationData]\n            window.flutter_inappwebview.callHandler('relocated', ...args);\n        }).catch(function (e) {\n            // If XPath conversion fails, still send CFI\n            var locationData = {\n                startCfi: location.start.cfi,\n                endCfi: location.end.cfi,\n                startXpath: null,\n                endXpath: null,\n                progress: percent\n            }\n            var args = [locationData]\n            window.flutter_inappwebview.callHandler('relocated', ...args);\n        });\n    });\n\n    rendition.on('displayError', function (e) {\n        window.flutter_inappwebview.callHandler('displayError');\n    })\n\n    rendition.on('markClicked', function (cfiRange) {\n        var args = [cfiRange.toString()]\n        window.flutter_inappwebview.callHandler('markClicked', ...args);\n    })\n\n    book.ready.then(function () {\n        book.locations.generate(1600).then(() => {\n            // Handle initial position after locations are generated\n            // XPath takes precedence over CFI\n            if (initialXPath && !initialXPathProcessed) {\n                initialXPathProcessed = true; // Mark as processed to prevent multiple calls\n                initialPositionLoading = true; // Mark that we're loading initial position\n                // Notify parent app that initial position loading has started\n                try {\n                    window.flutter_inappwebview.callHandler('initialPositionLoading', { type: 'xpath' });\n                } catch (e) {\n                    console.error('Error calling initialPositionLoading callback:', e);\n                }\n                xpathToCfi(initialXPath).then(function (convertedCfi) {\n                    if (convertedCfi && !xpathDisplayInProgress) {\n                        xpathDisplayInProgress = true; // Mark as in progress\n                        // Wait for the initial display to complete, then navigate to the XPath location\n                        // Use the displayed promise if available, or wait a bit\n                        var displayPromise = displayed;\n                        if (displayPromise && typeof displayPromise.then === 'function') {\n                            displayPromise.then(function () {\n                                setTimeout(function () {\n                                    if (xpathDisplayInProgress) { // Double-check flag\n                                        try {\n                                            rendition.display(convertedCfi);\n                                            xpathDisplayInProgress = false; // Mark as complete\n                                        } catch (e) {\n                                            console.error('Error displaying converted CFI:', e);\n                                            xpathDisplayInProgress = false; // Reset on error\n                                        }\n                                    }\n                                }, 50);\n                            }).catch(function (e) {\n                                console.error('Error waiting for initial display:', e);\n                                // Try anyway after a delay\n                                setTimeout(function () {\n                                    if (xpathDisplayInProgress) { // Double-check flag\n                                        try {\n                                            rendition.display(convertedCfi);\n                                            xpathDisplayInProgress = false; // Mark as complete\n                                        } catch (e2) {\n                                            console.error('Error displaying converted CFI after delay:', e2);\n                                            xpathDisplayInProgress = false; // Reset on error\n                                        }\n                                    }\n                                }, 200);\n                            });\n                        } else {\n                            // No promise, just wait a bit\n                            setTimeout(function () {\n                                if (xpathDisplayInProgress) { // Double-check flag\n                                    try {\n                                        rendition.display(convertedCfi);\n                                        xpathDisplayInProgress = false; // Mark as complete\n                                    } catch (e) {\n                                        console.error('Error displaying converted CFI:', e);\n                                        xpathDisplayInProgress = false; // Reset on error\n                                    }\n                                }\n                            }, 200);\n                        }\n                    } else {\n                        console.warn('Failed to convert XPath to CFI, falling back to CFI or default');\n                        if (cfi) {\n                            rendition.display(cfi);\n                            // initialPositionLoading flag will be cleared when \"displayed\" event fires\n                        } else {\n                            // No CFI fallback, clear the loading flag immediately\n                            initialPositionLoading = false;\n                            window.flutter_inappwebview.callHandler('initialPositionLoaded');\n                        }\n                    }\n                    window.flutter_inappwebview.callHandler('locationLoaded');\n                }).catch(function (e) {\n                    console.error('Error converting XPath to CFI in ready:', e);\n                    if (cfi) {\n                        rendition.display(cfi);\n                        // initialPositionLoading flag will be cleared when \"displayed\" event fires\n                    } else {\n                        // No CFI fallback, clear the loading flag immediately\n                        initialPositionLoading = false;\n                        window.flutter_inappwebview.callHandler('initialPositionLoaded');\n                    }\n                    window.flutter_inappwebview.callHandler('locationLoaded');\n                });\n            } else if (cfi) {\n                // CFI callback was already fired when we did the initial display above\n                // Just ensure locationLoaded is called\n                window.flutter_inappwebview.callHandler('locationLoaded');\n            } else {\n                window.flutter_inappwebview.callHandler('locationLoaded');\n            }\n        })\n    })\n\n    rendition.hooks.content.register((contents) => {\n        var doc = contents.document;\n        if (!doc) return;\n\n        // Track touch positions to detect horizontal swipes\n        var touchStartX = null;\n        var touchStartY = null;\n        var currentTouchX = null;\n        var currentTouchY = null;\n        var hasMoved = false; // Track if touch has moved significantly (swipe vs tap)\n        var touchStartTime = null; // Track when touch started\n\n        // Helper function to calculate normalized touch coordinates (0-1 range)\n        // Uses the same logic as selection coordinate calculation\n        function getNormalizedTouchCoordinates(touchEvent) {\n            try {\n                if (!touchEvent.touches || touchEvent.touches.length === 0) {\n                    return null;\n                }\n\n                var touch = touchEvent.touches[0];\n                // Touch coordinates are relative to the iframe viewport (same as selection clientRect)\n                var clientX = touch.clientX;\n                var clientY = touch.clientY;\n\n                // Get the WebView dimensions (parent window)\n                var webViewWidth = window.innerWidth;\n                var webViewHeight = window.innerHeight;\n\n                // Get the iframe element in the parent document\n                var iframe = contents.document.defaultView.frameElement;\n                if (!iframe) {\n                    // Fallback: use clientX/Y directly if no iframe\n                    return {\n                        x: clientX / webViewWidth,\n                        y: clientY / webViewHeight\n                    };\n                }\n\n                var iframeRect = iframe.getBoundingClientRect();\n\n                // Calculate absolute position in WebView (iframe offset + touch position)\n                // Same logic as selection: absoluteLeft = iframeRect.left + clientRect.left\n                var absoluteX = iframeRect.left + clientX;\n                var absoluteY = iframeRect.top + clientY;\n\n                // Normalize to 0-1 range relative to WebView dimensions\n                return {\n                    x: absoluteX / webViewWidth,\n                    y: absoluteY / webViewHeight\n                };\n            } catch (e) {\n                console.error('Error calculating touch coordinates:', e);\n                return null;\n            }\n        }\n\n        // Helper function to get normalized coordinates from changedTouches (for touchend)\n        // Uses the same logic as selection coordinate calculation\n        function getNormalizedTouchCoordinatesFromChanged(touchEvent) {\n            try {\n                if (!touchEvent.changedTouches || touchEvent.changedTouches.length === 0) {\n                    return null;\n                }\n\n                var touch = touchEvent.changedTouches[0];\n                // Touch coordinates are relative to the iframe viewport (same as selection clientRect)\n                var clientX = touch.clientX;\n                var clientY = touch.clientY;\n\n                // Get the WebView dimensions (parent window)\n                var webViewWidth = window.innerWidth;\n                var webViewHeight = window.innerHeight;\n\n                // Get the iframe element in the parent document\n                var iframe = contents.document.defaultView.frameElement;\n                if (!iframe) {\n                    // Fallback: use clientX/Y directly if no iframe\n                    return {\n                        x: clientX / webViewWidth,\n                        y: clientY / webViewHeight\n                    };\n                }\n\n                var iframeRect = iframe.getBoundingClientRect();\n\n                // Calculate absolute position in WebView (iframe offset + touch position)\n                // Same logic as selection: absoluteLeft = iframeRect.left + clientRect.left\n                var absoluteX = iframeRect.left + clientX;\n                var absoluteY = iframeRect.top + clientY;\n\n                // Normalize to 0-1 range relative to WebView dimensions\n                return {\n                    x: absoluteX / webViewWidth,\n                    y: absoluteY / webViewHeight\n                };\n            } catch (e) {\n                console.error('Error calculating touch coordinates:', e);\n                return null;\n            }\n        }\n\n        // Block horizontal swipe gestures when there's a selection\n        // This must be done at the document level in capture phase to intercept early\n        // Use { passive: false } to allow preventDefault() to work\n        doc.addEventListener('touchstart', function (e) {\n            // Fire onTouchDown callback with normalized coordinates FIRST (before any preventDefault)\n            var touchCoords = null;\n            try {\n                var coords = getNormalizedTouchCoordinates(e);\n                if (coords) {\n                    touchCoords = coords;\n                    // Store tap coordinates for later checking in selectionchange\n                    lastTapCoords = coords;\n                    window.flutter_inappwebview.callHandler('onTouchDown', coords.x, coords.y);\n                }\n            } catch (err) {\n                // Ignore errors in callback\n            }\n\n            if (hasActiveSelection()) {\n                // Store initial touch position and time to detect if this is a tap or swipe\n                if (e.touches && e.touches.length > 0) {\n                    touchStartX = e.touches[0].clientX;\n                    touchStartY = e.touches[0].clientY;\n                    currentTouchX = touchStartX;\n                    currentTouchY = touchStartY;\n                    touchStartTime = Date.now();\n                    hasMoved = false; // Reset movement flag\n                }\n                // Don't preventDefault yet - wait to see if it's a tap or swipe\n            } else {\n                // Track for normal swipe detection\n                if (e.touches && e.touches.length > 0) {\n                    touchStartX = e.touches[0].clientX;\n                    touchStartY = e.touches[0].clientY;\n                    currentTouchX = touchStartX;\n                    currentTouchY = touchStartY;\n                    touchStartTime = Date.now();\n                    hasMoved = false;\n                }\n            }\n        }, { capture: true, passive: false }); // Use options object with passive: false\n\n        doc.addEventListener('touchmove', function (e) {\n            if (hasActiveSelection()) {\n                // Update position\n                if (e.touches && e.touches.length > 0 && touchStartX !== null) {\n                    currentTouchX = e.touches[0].clientX;\n                    currentTouchY = e.touches[0].clientY;\n\n                    var deltaX = Math.abs(currentTouchX - touchStartX);\n                    var deltaY = Math.abs(currentTouchY - touchStartY);\n\n                    // If there's significant movement (more than 10px), it's a swipe - block it\n                    if (deltaX > 10 || deltaY > 10) {\n                        hasMoved = true;\n                        // Block horizontal swipes completely\n                        if (deltaX > 30 && deltaX > deltaY * 1.5) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                            e.stopImmediatePropagation();\n                            return false;\n                        }\n                        // Also block if it's a significant horizontal movement (even if not strictly horizontal)\n                        if (deltaX > 50) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                            e.stopImmediatePropagation();\n                            return false;\n                        }\n                    }\n                }\n            } else {\n                // Update current position for normal swipe detection\n                if (e.touches && e.touches.length > 0) {\n                    currentTouchX = e.touches[0].clientX;\n                    currentTouchY = e.touches[0].clientY;\n                }\n            }\n        }, { capture: true, passive: false }); // Use options object with passive: false\n\n        doc.addEventListener('touchend', function (e) {\n            // Fire onTouchUp callback with normalized coordinates\n            var tapCoords = null;\n            try {\n                var coords = getNormalizedTouchCoordinatesFromChanged(e);\n                if (coords) {\n                    tapCoords = coords;\n                    window.flutter_inappwebview.callHandler('onTouchUp', coords.x, coords.y);\n                }\n            } catch (err) {\n                // Ignore errors in callback\n            }\n\n            if (hasActiveSelection()) {\n                // Check if this was a tap (no significant movement) or a swipe\n                if (touchStartX !== null && currentTouchX !== null && touchStartTime !== null) {\n                    var deltaX = Math.abs(currentTouchX - touchStartX);\n                    var deltaY = Math.abs(currentTouchY - touchStartY);\n                    var touchDuration = Date.now() - touchStartTime;\n\n                    // If there was minimal movement (< 10px) and short duration (< 300ms), it's a tap\n                    if (!hasMoved && deltaX < 10 && deltaY < 10 && touchDuration < 300) {\n                        // Simple tap - allow normal behavior\n                    } else if (deltaX > 30 && deltaX > deltaY * 1.5) {\n                        // It was a horizontal swipe - block it\n                        e.preventDefault();\n                        e.stopPropagation();\n                        e.stopImmediatePropagation();\n                        return false;\n                    } else if (deltaX > 50) {\n                        // Significant horizontal movement - block it\n                        e.preventDefault();\n                        e.stopPropagation();\n                        e.stopImmediatePropagation();\n                        return false;\n                    }\n                }\n            }\n            // Reset tracking\n            touchStartX = null;\n            touchStartY = null;\n            currentTouchX = null;\n            currentTouchY = null;\n            hasMoved = false;\n            touchStartTime = null;\n            // Keep lastTapCoords for longer to allow click handler and selectionchange to check it\n            // Clear after a longer delay to handle quick taps\n            setTimeout(function () {\n                lastTapCoords = null;\n            }, 500);\n        }, { capture: true, passive: false }); // Use options object with passive: false\n\n        if (useCustomSwipe) {\n            const el = contents.document.documentElement;\n\n            if (el) {\n                detectSwipe(el, function (el, direction) {\n                    // Block swipes if there's an active selection\n                    if (hasActiveSelection()) {\n                        console.log('Blocked swipe - selection active, direction:', direction);\n                        return;\n                    }\n\n                    if (direction == 'l') {\n                        // Double-check before calling\n                        if (!hasActiveSelection()) {\n                            rendition.next();\n                        }\n                    }\n                    if (direction == 'r') {\n                        // Double-check before calling\n                        if (!hasActiveSelection()) {\n                            rendition.prev();\n                        }\n                    }\n                });\n            }\n        }\n\n        // Block epub.js built-in click/tap navigation when there's a selection\n        // epub.js typically handles clicks on the left/right sides of the page\n        try {\n            if (doc) {\n                // Helper function to check if event is in navigation zone and should be blocked\n                function shouldBlockNavigation(e) {\n                    if (!hasActiveSelection()) {\n                        return false;\n                    }\n\n                    // Don't block if clicking on links or interactive elements\n                    var target = e.target;\n                    if (target && target.tagName &&\n                        target.tagName.toLowerCase() !== 'a' &&\n                        target.tagName.toLowerCase() !== 'button' &&\n                        !target.closest('a') &&\n                        !target.closest('button')) {\n                        // Get click/touch position\n                        var clickX = null;\n                        if (e.clientX !== undefined) {\n                            clickX = e.clientX;\n                        } else if (e.touches && e.touches.length > 0) {\n                            clickX = e.touches[0].clientX;\n                        } else if (e.changedTouches && e.changedTouches.length > 0) {\n                            clickX = e.changedTouches[0].clientX;\n                        }\n\n                        if (clickX !== null) {\n                            var pageWidth = doc.documentElement.clientWidth || window.innerWidth;\n                            var leftThird = pageWidth / 3;\n                            var rightThird = pageWidth * 2 / 3;\n\n                            // Block navigation clicks/taps in left/right thirds when selection is active\n                            if (clickX < leftThird || clickX > rightThird) {\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n                }\n\n                // Intercept click events to prevent navigation when selection is active\n                doc.addEventListener('click', function (e) {\n                    // Block navigation clicks if needed\n                    if (shouldBlockNavigation(e)) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                        return false;\n                    }\n                }, { capture: true, passive: false }); // Use options object with passive: false\n\n                // Also intercept touch events for mobile devices (backup)\n                // But only block if it's in navigation zone AND not a simple tap\n                doc.addEventListener('touchend', function (e) {\n                    // Check if this was a simple tap\n                    var wasSimpleTap = false;\n                    if (touchStartX !== null && currentTouchX !== null && touchStartTime !== null) {\n                        var deltaX = Math.abs(currentTouchX - touchStartX);\n                        var deltaY = Math.abs(currentTouchY - touchStartY);\n                        var touchDuration = Date.now() - touchStartTime;\n                        wasSimpleTap = (!hasMoved && deltaX < 10 && deltaY < 10 && touchDuration < 300);\n                    }\n\n                    // Only block navigation if it's NOT a simple tap\n                    if (!wasSimpleTap && shouldBlockNavigation(e)) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                        return false;\n                    }\n                }, { capture: true, passive: false }); // Use options object with passive: false\n            }\n        } catch (e) {\n            // Ignore errors\n        }\n    });\n    rendition.themes.fontSize(fontSize + \"px\");\n    //set background and foreground color\n    updateTheme(backgroundColor, foregroundColor);\n}\n\nwindow.addEventListener(\"flutterInAppWebViewPlatformReady\", function (event) {\n    window.flutter_inappwebview.callHandler('readyToLoad');\n});\n\n// Helper function to check if there's an active text selection (global version)\nfunction hasActiveSelection() {\n    // Check our tracking variables first\n    if (isSelecting || lastCfiRange) {\n        return true;\n    }\n\n    // Also check actual DOM selection across all content frames\n    try {\n        if (typeof rendition !== 'undefined' && rendition) {\n            var allContents = rendition.getContents();\n            for (var i = 0; i < allContents.length; i++) {\n                try {\n                    var contents = allContents[i];\n                    if (contents.window && contents.window.getSelection) {\n                        var selection = contents.window.getSelection();\n                        if (selection && selection.rangeCount > 0) {\n                            var range = selection.getRangeAt(0);\n                            var selectedText = selection.toString();\n                            if (selectedText && range && !range.collapsed) {\n                                return true;\n                            }\n                        }\n                    }\n                } catch (e) {\n                    // Ignore errors for this content frame\n                }\n            }\n\n            // Also check parent window selection\n            if (window.getSelection) {\n                var parentSelection = window.getSelection();\n                if (parentSelection && parentSelection.rangeCount > 0) {\n                    var parentRange = parentSelection.getRangeAt(0);\n                    var parentText = parentSelection.toString();\n                    if (parentText && parentRange && !parentRange.collapsed) {\n                        return true;\n                    }\n                }\n            }\n        }\n    } catch (e) {\n        // Ignore errors\n    }\n\n    return false;\n}\n\n// Store original rendition methods to override them\nvar originalNext = null;\nvar originalPrev = null;\nvar originalDisplay = null;\n\n// Override rendition methods to block when selection exists\nfunction setupRenditionBlocking() {\n    if (typeof rendition !== 'undefined' && rendition && !originalNext) {\n        // Store original methods\n        originalNext = rendition.next.bind(rendition);\n        originalPrev = rendition.prev.bind(rendition);\n        originalDisplay = rendition.display.bind(rendition);\n\n        // Override next()\n        rendition.next = function () {\n            if (hasActiveSelection()) {\n                console.log('Blocked next() - selection active');\n                return Promise.resolve(rendition.location);\n            }\n            return originalNext();\n        };\n\n        // Override prev()\n        rendition.prev = function () {\n            if (hasActiveSelection()) {\n                console.log('Blocked prev() - selection active');\n                return Promise.resolve(rendition.location);\n            }\n            return originalPrev();\n        };\n\n        // Override display() - this is what actually changes the page\n        rendition.display = function (cfi) {\n            if (hasActiveSelection()) {\n                console.log('Blocked display() - selection active, cfi:', cfi);\n                return Promise.resolve(rendition.location);\n            }\n            return originalDisplay(cfi);\n        };\n    }\n}\n\n//move to next page\nfunction next() {\n    // Block navigation if there's an active selection\n    if (hasActiveSelection()) {\n        console.log('Blocked next() - selection active');\n        return;\n    }\n    if (rendition) {\n        rendition.next();\n    }\n}\n\n//move to previous page\nfunction previous() {\n    // Block navigation if there's an active selection\n    if (hasActiveSelection()) {\n        console.log('Blocked previous() - selection active');\n        return;\n    }\n    if (rendition) {\n        rendition.prev();\n    }\n}\n\n//move to given cfi location or xpath\nfunction toCfi(cfiOrXPath) {\n    // Check if it looks like an XPath (starts with /)\n    if (cfiOrXPath && cfiOrXPath.startsWith('/')) {\n        xpathToCfi(cfiOrXPath).then(function (convertedCfi) {\n            if (convertedCfi) {\n                rendition.display(convertedCfi);\n            } else {\n                console.error('Failed to convert XPath to CFI:', cfiOrXPath);\n            }\n        }).catch(function (e) {\n            console.error('Error converting XPath to CFI:', e);\n        });\n    } else {\n        // Treat as CFI\n        rendition.display(cfiOrXPath);\n    }\n}\n\n//get all chapters\nfunction getChapters() {\n    return chapters;\n}\n\nasync function getBookInfo() {\n    const metadata = book.package.metadata;\n    metadata['coverImage'] = book.cover;\n    return metadata;\n}\n\nfunction getCurrentLocation() {\n    var percent = rendition.location.start.percentage;\n\n    // Convert CFIs to XPath\n    return Promise.all([\n        cfiToXPath(rendition.location.start.cfi),\n        cfiToXPath(rendition.location.end.cfi)\n    ]).then(function (xpaths) {\n        return {\n            startCfi: rendition.location.start.cfi,\n            endCfi: rendition.location.end.cfi,\n            startXpath: xpaths[0],\n            endXpath: xpaths[1],\n            progress: percent\n        };\n    }).catch(function (e) {\n        // If XPath conversion fails, still return CFI\n        return {\n            startCfi: rendition.location.start.cfi,\n            endCfi: rendition.location.end.cfi,\n            startXpath: null,\n            endXpath: null,\n            progress: percent\n        };\n    });\n}\n\n///parsing chapters and subitems recursively\nvar parseChapters = function (toc) {\n    var chapters = []\n    toc.forEach(function (chapter) {\n        chapters.push({\n            title: chapter.label,\n            href: chapter.href,\n            id: chapter.id,\n            subitems: parseChapters(chapter.subitems)\n        })\n    })\n    return chapters;\n}\n\nfunction searchInBook(query) {\n    search(query).then(function (data) {\n        // Convert each search result's CFI to XPath\n        var xpathPromises = data.map(function (result) {\n            return cfiToXPath(result.cfi).then(function (xpath) {\n                return {\n                    cfi: result.cfi,\n                    excerpt: result.excerpt,\n                    xpath: xpath\n                };\n            }).catch(function (e) {\n                // If XPath conversion fails, still return CFI\n                return {\n                    cfi: result.cfi,\n                    excerpt: result.excerpt,\n                    xpath: null\n                };\n            });\n        });\n\n        Promise.all(xpathPromises).then(function (resultsWithXpath) {\n            var args = [resultsWithXpath]\n            window.flutter_inappwebview.callHandler('search', ...args);\n        }).catch(function (e) {\n            // If all conversions fail, still send original data\n            var args = [data]\n            window.flutter_inappwebview.callHandler('search', ...args);\n        });\n    })\n}\n\n\n// adds highlight with given color\nfunction addHighlight(cfiRange, color, opacity) {\n    rendition.annotations.highlight(cfiRange, {}, (e) => {\n        // Highlight clicked handler (can be extended if needed)\n    }, \"hl\", { \"fill\": color, \"fill-opacity\": '0.3', \"mix-blend-mode\": \"multiply\" });\n}\n\nfunction addUnderLine(cfiString) {\n    rendition.annotations.underline(cfiString)\n}\n\nfunction addMark(cfiString) {\n    rendition.annotations.mark(cfiString)\n}\n\nfunction removeHighlight(cfiString) {\n    rendition.annotations.remove(cfiString, \"highlight\");\n}\n\nfunction removeUnderLine(cfiString) {\n    rendition.annotations.remove(cfiString, \"underline\");\n}\n\nfunction removeMark(cfiString) {\n    rendition.annotations.remove(cfiString, \"mark\");\n}\n\nfunction clearSelection() {\n    try {\n        if (typeof rendition !== 'undefined' && rendition) {\n            // Clear selection in all content frames (iframes)\n            rendition.getContents().forEach(function (contents) {\n                try {\n                    if (contents.window.getSelection) {\n                        contents.window.getSelection().removeAllRanges();\n                    }\n                } catch (e) {\n                    // Ignore errors if iframe is not accessible\n                }\n            });\n\n            // Also clear selection in parent window as fallback\n            if (window.getSelection) {\n                window.getSelection().removeAllRanges();\n            }\n\n            // Notify Flutter that selection was cleared - only if we've actually sent a selection\n            if (hasSentSelection && (isSelecting || lastCfiRange) && window.flutter_inappwebview && window.flutter_inappwebview.callHandler) {\n                isSelecting = false;\n                lastCfiRange = null;\n                hasSentSelection = false;\n                if (selectionTimeout) {\n                    clearTimeout(selectionTimeout);\n                    selectionTimeout = null;\n                }\n                window.flutter_inappwebview.callHandler('selectionCleared');\n            }\n        } else {\n            // Fallback if rendition is not available\n            if (window.getSelection) {\n                window.getSelection().removeAllRanges();\n            }\n        }\n    } catch (e) {\n        console.error('Error clearing selection:', e);\n    }\n}\n\n// Explicitly attach to window for global access\nwindow.clearSelection = clearSelection;\n\nfunction toProgress(progress) {\n    var cfi = book.locations.cfiFromPercentage(progress);\n    rendition.display(cfi);\n}\n\n\nfunction search(q) {\n    return Promise.all(\n        book.spine.spineItems.map(item => item.load(book.load.bind(book)).then(item.find.bind(item, q)).finally(item.unload.bind(item)))\n    ).then(results => Promise.resolve([].concat.apply([], results)));\n};\n\nfunction setSpread(spread) {\n    rendition.spread(spread);\n}\n\nfunction setFlow(flow) {\n    rendition.flow(flow);\n}\n\nfunction setManager(manager) {\n    rendition.manager(manager);\n}\n\nfunction setFontSize(fontSize) {\n    rendition.themes.fontSize(`${fontSize}px`);\n    rendition.reportLocation();\n}\n\n//get current page text\nfunction getCurrentPageText() {\n    var startCfi = rendition.location.start.cfi\n    var endCfi = rendition.location.end.cfi\n    var cfiRange = makeRangeCfi(startCfi, endCfi)\n    book.getRange(cfiRange).then(function (range) {\n        var text = range.toString();\n        // Convert CFI range to XPath\n        cfiRangeToXPath(cfiRange).then(function (xpathRange) {\n            var args = [text, cfiRange, xpathRange]\n            window.flutter_inappwebview.callHandler('epubText', ...args);\n        }).catch(function (e) {\n            // If XPath conversion fails, still send CFI\n            var args = [text, cfiRange, null]\n            window.flutter_inappwebview.callHandler('epubText', ...args);\n        });\n    })\n}\n\n//get text from a range\nfunction getTextFromCfi(startCfi, endCfi) {\n    var cfiRange = makeRangeCfi(startCfi, endCfi)\n    book.getRange(cfiRange).then(function (range) {\n        var text = range.toString();\n        // Convert CFI range to XPath\n        cfiRangeToXPath(cfiRange).then(function (xpathRange) {\n            var args = [text, cfiRange, xpathRange]\n            window.flutter_inappwebview.callHandler('epubText', ...args);\n        }).catch(function (e) {\n            // If XPath conversion fails, still send CFI\n            var args = [text, cfiRange, null]\n            window.flutter_inappwebview.callHandler('epubText', ...args);\n        });\n    })\n}\n\n///update theme\nfunction updateTheme(backgroundColor, foregroundColor) {\n    var themeObj = {};\n\n    // Build theme object with available colors\n    // Only include properties that are provided and not empty\n    if (backgroundColor && backgroundColor !== \"\" && backgroundColor !== \"null\") {\n        themeObj[\"background\"] = backgroundColor;\n    }\n    if (foregroundColor && foregroundColor !== \"\" && foregroundColor !== \"null\") {\n        themeObj[\"color\"] = foregroundColor;\n    }\n\n    // Update theme if at least one color is provided\n    if (Object.keys(themeObj).length > 0) {\n        rendition.themes.register(\"dark\", { \"body\": themeObj });\n        rendition.themes.select(\"dark\");\n    }\n}\n\nconst makeRangeCfi = (a, b) => {\n    const CFI = new ePub.CFI()\n    const start = CFI.parse(a), end = CFI.parse(b)\n    const cfi = {\n        range: true,\n        base: start.base,\n        path: {\n            steps: [],\n            terminal: null\n        },\n        start: start.path,\n        end: end.path\n    }\n    const len = cfi.start.steps.length\n    for (let i = 0; i < len; i++) {\n        if (CFI.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n            if (i == len - 1) {\n                // Last step is equal, check terminals\n                if (cfi.start.terminal === cfi.end.terminal) {\n                    // CFI's are equal\n                    cfi.path.steps.push(cfi.start.steps[i])\n                    // Not a range\n                    cfi.range = false\n                }\n            } else cfi.path.steps.push(cfi.start.steps[i])\n        } else break\n    }\n    cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length)\n    cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length)\n\n    return 'epubcfi(' + CFI.segmentString(cfi.base)\n        + '!' + CFI.segmentString(cfi.path)\n        + ',' + CFI.segmentString(cfi.start)\n        + ',' + CFI.segmentString(cfi.end)\n        + ')'\n}\n\n// Convert a DOM node to XPath\nfunction getXPath(node) {\n    if (node.nodeType === Node.DOCUMENT_NODE) {\n        return '/';\n    }\n\n    if (node.nodeType === Node.TEXT_NODE) {\n        var parent = node.parentNode;\n        var xpath = getXPath(parent);\n        var index = 1;\n        var sibling = node.previousSibling;\n        while (sibling) {\n            if (sibling.nodeType === Node.TEXT_NODE && sibling.nodeName === node.nodeName) {\n                index++;\n            }\n            sibling = sibling.previousSibling;\n        }\n        return xpath + '/text()[' + index + ']';\n    }\n\n    if (node.nodeType === Node.ELEMENT_NODE) {\n        var parts = [];\n        var current = node;\n\n        while (current && current.nodeType === Node.ELEMENT_NODE) {\n            var index = 1;\n            var sibling = current.previousSibling;\n            while (sibling) {\n                if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName === current.nodeName) {\n                    index++;\n                }\n                sibling = sibling.previousSibling;\n            }\n\n            var tagName = current.nodeName.toLowerCase();\n            var xpathSegment = tagName + '[' + index + ']';\n\n            // Add ID if available for more precise targeting\n            if (current.id) {\n                xpathSegment = tagName + '[@id=\"' + current.id + '\"]';\n            }\n\n            parts.unshift(xpathSegment);\n            current = current.parentNode;\n        }\n\n        return '/' + parts.join('/');\n    }\n\n    return '';\n}\n\n// Convert CFI to XPath/XPointer\n// Returns a promise that resolves to an XPointer string or null if conversion fails\nfunction cfiToXPath(cfiString) {\n    if (!cfiString) {\n        return Promise.resolve(null);\n    }\n\n    try {\n        var cfi = new ePub.CFI(cfiString);\n        var spineIndex = cfi.spinePos;\n\n        // Get the spine item\n        var spineItem = book.spine.get(spineIndex);\n        if (!spineItem) {\n            return Promise.resolve(null);\n        }\n\n        // Load the item and convert CFI to Range\n        return spineItem.load(book.load.bind(book)).then(function () {\n            try {\n                var range = cfi.toRange(spineItem.document);\n                if (!range) {\n                    return null;\n                }\n\n                // Build XPath from the range\n                var startXPath = getXPath(range.startContainer);\n                var endXPath = getXPath(range.endContainer);\n\n                // Convert to KoReader format: /body/DocFragment[N]/body/...\n                // Extract the path after /html[N]/body[N] and prepend /body/DocFragment[N]/body\n                function convertToKoReaderFormat(xpath, offset) {\n                    // Match /html[N]/body[N] and extract the rest\n                    var match = xpath.match(/^\\/html\\[\\d+\\]\\/body\\[\\d+\\](.*)$/);\n                    if (match) {\n                        var elementPath = match[1] || '';\n                        // Convert /text()[1] to /text() for KoReader format\n                        elementPath = elementPath.replace(/\\/text\\(\\)\\[\\d+\\]$/, '/text()');\n                        // DocFragment index is spineIndex + 1 (1-based)\n                        var docFragmentIndex = spineIndex + 1;\n                        // Build KoReader format: /body/DocFragment[N]/body/...\n                        var koreaderPath = '/body/DocFragment[' + docFragmentIndex + ']/body' + elementPath;\n                        // Add offset for text nodes\n                        if (offset !== undefined && offset !== null) {\n                            koreaderPath += '.' + offset;\n                        }\n                        return koreaderPath;\n                    }\n                    // If format doesn't match, return original with offset\n                    if (offset !== undefined && offset !== null) {\n                        return xpath + '.' + offset;\n                    }\n                    return xpath;\n                }\n\n                // Add offset for text nodes and convert to KoReader format\n                var startOffset = null;\n                var endOffset = null;\n                if (range.startContainer.nodeType === Node.TEXT_NODE) {\n                    startOffset = range.startOffset;\n                }\n                if (range.endContainer.nodeType === Node.TEXT_NODE) {\n                    endOffset = range.endOffset;\n                }\n\n                var startXPathKoReader = convertToKoReaderFormat(startXPath, startOffset);\n                var endXPathKoReader = convertToKoReaderFormat(endXPath, endOffset);\n\n                // Format as XPointer: /body/DocFragment[1]/body/div[2]/p[3]/text().123\n                // For ranges, we return start and end separated by comma\n                if (startXPathKoReader === endXPathKoReader && startOffset === endOffset) {\n                    return startXPathKoReader;\n                } else {\n                    return startXPathKoReader + ',' + endXPathKoReader;\n                }\n            } catch (e) {\n                console.error('Error converting CFI to XPath:', e);\n                return null;\n            }\n        }).catch(function (e) {\n            console.error('Error loading spine item for CFI conversion:', e);\n            return null;\n        });\n    } catch (e) {\n        console.error('Error parsing CFI:', e);\n        return Promise.resolve(null);\n    }\n}\n\n// Helper to convert CFI range to XPath range\nfunction cfiRangeToXPath(cfiRangeString) {\n    if (!cfiRangeString) {\n        return Promise.resolve(null);\n    }\n\n    try {\n        // Parse the CFI range to extract start and end CFIs\n        var cfi = new ePub.CFI(cfiRangeString);\n        var spineIndex = cfi.spinePos;\n\n        var spineItem = book.spine.get(spineIndex);\n        if (!spineItem) {\n            return Promise.resolve(null);\n        }\n\n        return spineItem.load(book.load.bind(book)).then(function () {\n            try {\n                var range = cfi.toRange(spineItem.document);\n                if (!range) {\n                    return null;\n                }\n\n                var startXPath = getXPath(range.startContainer);\n                var endXPath = getXPath(range.endContainer);\n\n                // Convert to KoReader format: /body/DocFragment[N]/body/...\n                function convertToKoReaderFormat(xpath, offset) {\n                    // Match /html[N]/body[N] and extract the rest\n                    var match = xpath.match(/^\\/html\\[\\d+\\]\\/body\\[\\d+\\](.*)$/);\n                    if (match) {\n                        var elementPath = match[1] || '';\n                        // Convert /text()[1] to /text() for KoReader format\n                        elementPath = elementPath.replace(/\\/text\\(\\)\\[\\d+\\]$/, '/text()');\n                        // DocFragment index is spineIndex + 1 (1-based)\n                        var docFragmentIndex = spineIndex + 1;\n                        // Build KoReader format: /body/DocFragment[N]/body/...\n                        var koreaderPath = '/body/DocFragment[' + docFragmentIndex + ']/body' + elementPath;\n                        // Add offset for text nodes\n                        if (offset !== undefined && offset !== null) {\n                            koreaderPath += '.' + offset;\n                        }\n                        return koreaderPath;\n                    }\n                    // If format doesn't match, return original with offset\n                    if (offset !== undefined && offset !== null) {\n                        return xpath + '.' + offset;\n                    }\n                    return xpath;\n                }\n\n                // Add offset for text nodes and convert to KoReader format\n                var startOffset = null;\n                var endOffset = null;\n                if (range.startContainer.nodeType === Node.TEXT_NODE) {\n                    startOffset = range.startOffset;\n                }\n                if (range.endContainer.nodeType === Node.TEXT_NODE) {\n                    endOffset = range.endOffset;\n                }\n\n                var startXPathKoReader = convertToKoReaderFormat(startXPath, startOffset);\n                var endXPathKoReader = convertToKoReaderFormat(endXPath, endOffset);\n\n                if (startXPathKoReader === endXPathKoReader && startOffset === endOffset) {\n                    return startXPathKoReader;\n                } else {\n                    return startXPathKoReader + ',' + endXPathKoReader;\n                }\n            } catch (e) {\n                console.error('Error converting CFI range to XPath:', e);\n                return null;\n            }\n        }).catch(function (e) {\n            console.error('Error loading spine item for CFI range conversion:', e);\n            return null;\n        });\n    } catch (e) {\n        console.error('Error parsing CFI range:', e);\n        return Promise.resolve(null);\n    }\n}\n\n// Convert XPath/XPointer to CFI\n// Returns a promise that resolves to a CFI string or null if conversion fails\nfunction xpathToCfi(xpathString) {\n    if (!xpathString) {\n        return Promise.resolve(null);\n    }\n\n    try {\n        // Parse XPath - handle ranges (comma-separated) and offsets\n        var parts = xpathString.split(',');\n        var startXPath = parts[0].trim();\n        var endXPath = parts.length > 1 ? parts[1].trim() : startXPath;\n\n        // Extract offset from XPath if present (e.g., /path/to/text().123)\n        var startOffset = 0;\n        var endOffset = 0;\n        var startXPathWithoutOffset = startXPath;\n        var endXPathWithoutOffset = endXPath;\n\n        var startOffsetMatch = startXPath.match(/\\.(\\d+)$/);\n        if (startOffsetMatch) {\n            startOffset = parseInt(startOffsetMatch[1]);\n            startXPathWithoutOffset = startXPath.replace(/\\.\\d+$/, '');\n        }\n\n        var endOffsetMatch = endXPath.match(/\\.(\\d+)$/);\n        if (endOffsetMatch) {\n            endOffset = parseInt(endOffsetMatch[1]);\n            endXPathWithoutOffset = endXPath.replace(/\\.\\d+$/, '');\n        }\n\n        // Extract DocFragment index if present (KoReader format: /body/DocFragment[9]/body/...)\n        var docFragmentIndex = null;\n        var docFragmentMatch = startXPathWithoutOffset.match(/\\/DocFragment\\[(\\d+)\\]/);\n        if (docFragmentMatch) {\n            docFragmentIndex = parseInt(docFragmentMatch[1]) - 1; // Convert to 0-based index\n            // Remove /body/DocFragment[N]/ part, leaving /body/... or just the content path\n            startXPathWithoutOffset = startXPathWithoutOffset.replace(/^\\/body\\/DocFragment\\[\\d+\\]/, '');\n        }\n\n        // Try to find the node in each spine item (or just the specific one if DocFragment index was found)\n        // Optimize: check sequentially and stop on first match to avoid loading all spine items\n        var spineItemsToCheck = docFragmentIndex !== null\n            ? [book.spine.spineItems[docFragmentIndex]].filter(function (item) { return item != null; })\n            : book.spine.spineItems;\n\n        // Optimize: if no DocFragment index, try to check currently displayed spine item first\n        // Create a mapping to track original indices when reordering\n        var indexMap = [];\n        for (var mapIdx = 0; mapIdx < spineItemsToCheck.length; mapIdx++) {\n            indexMap.push(mapIdx);\n        }\n\n        if (docFragmentIndex === null && rendition && rendition.location) {\n            try {\n                var currentLocation = rendition.location;\n                if (currentLocation && currentLocation.start && currentLocation.start.index !== undefined) {\n                    var currentSpineIndex = currentLocation.start.index;\n                    if (currentSpineIndex >= 0 && currentSpineIndex < spineItemsToCheck.length) {\n                        // Check current spine item first by moving it to the front\n                        var currentItem = spineItemsToCheck[currentSpineIndex];\n                        var currentIndexInMap = indexMap[currentSpineIndex];\n                        spineItemsToCheck = [currentItem].concat(\n                            spineItemsToCheck.slice(0, currentSpineIndex),\n                            spineItemsToCheck.slice(currentSpineIndex + 1)\n                        );\n                        indexMap = [currentIndexInMap].concat(\n                            indexMap.slice(0, currentSpineIndex),\n                            indexMap.slice(currentSpineIndex + 1)\n                        );\n                    }\n                }\n            } catch (e) {\n                // Silently fail - optimization is optional\n            }\n        }\n\n        // Sequential check function that stops on first match\n        function checkSpineItemSequentially(itemIndex) {\n            if (itemIndex >= spineItemsToCheck.length) {\n                // All items checked, no match found\n                return Promise.resolve(null);\n            }\n\n            var item = spineItemsToCheck[itemIndex];\n            // Use the mapped index to get the correct original spine index for CFI creation\n            var index = docFragmentIndex !== null ? docFragmentIndex : indexMap[itemIndex];\n\n            // Check if document is already loaded to avoid unnecessary loading\n            var doc = item.document;\n            var loadPromise = doc ? Promise.resolve() : item.load(book.load.bind(book));\n\n            return loadPromise.then(function () {\n                try {\n                    doc = item.document;\n                    if (!doc) {\n                        return null;\n                    }\n\n                    var startNode = null;\n                    var endNode = null;\n\n                    // Parse and resolve XPath manually (following Readest's approach)\n                    // This is more reliable than XPath evaluation in epub.js context\n                    function resolveXPointerPath(path) {\n                        var elementPath = '';\n                        var current = doc.body || doc.documentElement;\n\n                        if (!current) {\n                            return null;\n                        }\n\n                        // Handle empty path - return body element\n                        if (!path || path === '') {\n                            return current;\n                        }\n\n                        // Handle KoReader format: /body/DocFragment[N]/body/p[5]/text()\n                        var koreaderMatch = path.match(/^\\/body\\/DocFragment\\[\\d+\\]\\/body(.*)$/);\n                        if (koreaderMatch) {\n                            elementPath = koreaderMatch[1] || '';\n                        } else {\n                            // Handle our library's format: /html[1]/body[1]/p[1]/text()[1]\n                            var ourFormatMatch = path.match(/^\\/html\\[\\d+\\]\\/body\\[\\d+\\](.*)$/);\n                            if (ourFormatMatch) {\n                                elementPath = ourFormatMatch[1] || '';\n                            } else {\n                                // Try /body format\n                                var bodyMatch = path.match(/^\\/body(.*)$/);\n                                if (bodyMatch) {\n                                    elementPath = bodyMatch[1] || '';\n                                } else {\n                                    // Try /html format\n                                    var htmlMatch = path.match(/^\\/html\\[\\d+\\](.*)$/);\n                                    if (htmlMatch) {\n                                        elementPath = htmlMatch[1] || '';\n                                    } else {\n                                        return null;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (!elementPath || elementPath === '') {\n                            return current;\n                        }\n\n                        // Parse path segments (e.g., /p[5]/text() or /p[1]/text()[1] -> ['p[5]'] or ['p[1]', 'text()[1]'])\n                        var segments = elementPath.split('/').filter(function (s) { return s.length > 0; });\n\n                        for (var s = 0; s < segments.length; s++) {\n                            var segment = segments[s];\n\n                            // Handle text() or text()[1] - we'll handle this separately\n                            if (segment === 'text()' || segment.match(/^text\\(\\)\\[\\d+\\]$/)) {\n                                break; // Stop here, current is the element containing the text\n                            }\n\n                            // Match tag[index] or just tag\n                            var segmentWithIndexMatch = segment.match(/^(\\w+)\\[(\\d+)\\]$/);\n                            var segmentWithoutIndexMatch = segment.match(/^(\\w+)$/);\n\n                            var tagName = null;\n                            var index = 0;\n\n                            if (segmentWithIndexMatch) {\n                                tagName = segmentWithIndexMatch[1].toLowerCase();\n                                index = parseInt(segmentWithIndexMatch[2], 10) - 1; // Convert to 0-based\n                            } else if (segmentWithoutIndexMatch) {\n                                tagName = segmentWithoutIndexMatch[1].toLowerCase();\n                                index = 0;\n                            } else {\n                                return null;\n                            }\n\n                            // Find children with matching tag name\n                            var children = Array.from(current.children || []).filter(function (child) {\n                                return child.nodeType === Node.ELEMENT_NODE &&\n                                    child.tagName.toLowerCase() === tagName;\n                            });\n\n                            if (index >= children.length) {\n                                return null;\n                            }\n\n                            current = children[index];\n                        }\n\n                        return current;\n                    }\n\n                    // Resolve the start element\n                    var startElement = resolveXPointerPath(startXPathWithoutOffset);\n                    var startOffsetInNode = startOffset; // Default to original offset\n\n                    if (startElement) {\n                        // Handle text offset if present\n                        // If we have an offset (including 0) or explicit /text() in path, treat it as text node offset\n                        // Empty path with offset means we're targeting text nodes within the resolved element\n                        var hasTextOffset = startXPathWithoutOffset.includes('/text()') ||\n                            (startOffset >= 0 && (startXPathWithoutOffset === '' || startXPathWithoutOffset === '/body'));\n\n                        if (hasTextOffset) {\n                            // Find text node at the specified offset\n                            var textNodes = [];\n                            var walker = doc.createTreeWalker(startElement, NodeFilter.SHOW_TEXT, null, false);\n                            var textNode;\n                            while (textNode = walker.nextNode()) {\n                                if (textNode.textContent && textNode.textContent.length > 0) {\n                                    textNodes.push(textNode);\n                                }\n                            }\n\n                            if (textNodes.length > 0) {\n                                // If offset is 0, use the first text node\n                                if (startOffset === 0) {\n                                    startNode = textNodes[0];\n                                    startOffsetInNode = 0;\n                                } else {\n                                    // Calculate cumulative offset to find the right text node\n                                    var currentOffset = 0;\n                                    var targetTextNode = null;\n                                    var offsetInNode = 0;\n\n                                    for (var t = 0; t < textNodes.length; t++) {\n                                        var tn = textNodes[t];\n                                        var nodeLength = tn.textContent ? tn.textContent.length : 0;\n\n                                        // If offset is within this text node's range\n                                        if (currentOffset + nodeLength > startOffset) {\n                                            targetTextNode = tn;\n                                            offsetInNode = startOffset - currentOffset;\n                                            break;\n                                        }\n\n                                        currentOffset += nodeLength;\n                                    }\n\n                                    if (targetTextNode) {\n                                        startNode = targetTextNode;\n                                        startOffsetInNode = offsetInNode;\n                                    } else {\n                                        // Offset beyond all text, use last text node\n                                        var lastNode = textNodes[textNodes.length - 1];\n                                        startNode = lastNode;\n                                        var lastLength = lastNode.textContent ? lastNode.textContent.length : 0;\n                                        startOffsetInNode = lastLength;\n                                    }\n                                }\n                            } else {\n                                // No text nodes found, use the element itself\n                                startNode = startElement;\n                                startOffsetInNode = 0;\n                            }\n                        } else {\n                            // No text offset, use the element itself\n                            startNode = startElement;\n                            startOffsetInNode = 0;\n                        }\n                    }\n\n                    // If manual resolution failed, try XPath evaluation as fallback\n                    if (!startNode) {\n                        // Build XPath variations to try\n                        var xpathVariations = [startXPathWithoutOffset];\n\n                        if (startXPathWithoutOffset.startsWith('/body/')) {\n                            xpathVariations.push('/html' + startXPathWithoutOffset);\n                            xpathVariations.push(startXPathWithoutOffset.replace(/^\\/body\\//, '/'));\n                        }\n\n                        try {\n                            for (var v = 0; v < xpathVariations.length && !startNode; v++) {\n                                var xpathToTry = xpathVariations[v];\n                                try {\n                                    var startResult = doc.evaluate(xpathToTry, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);\n                                    startNode = startResult.singleNodeValue;\n                                    if (startNode) {\n                                        break;\n                                    }\n                                } catch (e) {\n                                    // Try next variation\n                                }\n                            }\n                        } catch (e) {\n                            // XPath evaluation failed, continue\n                        }\n                    }\n\n                    // Resolve end node (same approach as start node)\n                    var endOffsetInNode = endOffset; // Default to original offset\n                    if (parts.length > 1) {\n                        var endElement = resolveXPointerPath(endXPathWithoutOffset);\n                        if (endElement) {\n                            // Handle text offset if present (same logic as start node)\n                            var hasEndTextOffset = endXPathWithoutOffset.includes('/text()') ||\n                                (endOffset >= 0 && (endXPathWithoutOffset === '' || endXPathWithoutOffset === '/body'));\n\n                            if (hasEndTextOffset) {\n                                var endTextNodes = [];\n                                var endWalker = doc.createTreeWalker(endElement, NodeFilter.SHOW_TEXT, null, false);\n                                var endTextNode;\n                                while (endTextNode = endWalker.nextNode()) {\n                                    if (endTextNode.textContent && endTextNode.textContent.length > 0) {\n                                        endTextNodes.push(endTextNode);\n                                    }\n                                }\n\n                                if (endTextNodes.length > 0) {\n                                    var endCurrentOffset = 0;\n                                    var endTargetTextNode = null;\n                                    var endOffsetInNodeCalc = 0;\n\n                                    for (var t = 0; t < endTextNodes.length; t++) {\n                                        var tn = endTextNodes[t];\n                                        var nodeLength = tn.textContent ? tn.textContent.length : 0;\n\n                                        if (endCurrentOffset + nodeLength >= endOffset) {\n                                            endTargetTextNode = tn;\n                                            endOffsetInNodeCalc = endOffset - endCurrentOffset;\n                                            break;\n                                        }\n\n                                        endCurrentOffset += nodeLength;\n                                    }\n\n                                    if (endTargetTextNode) {\n                                        endNode = endTargetTextNode;\n                                        endOffsetInNode = endOffsetInNodeCalc;\n                                    } else if (endTextNodes.length > 0) {\n                                        var lastEndNode = endTextNodes[endTextNodes.length - 1];\n                                        endNode = lastEndNode;\n                                        endOffsetInNode = lastEndNode.textContent ? lastEndNode.textContent.length : 0;\n                                    } else {\n                                        endNode = endElement;\n                                        endOffsetInNode = 0;\n                                    }\n                                } else {\n                                    endNode = endElement;\n                                    endOffsetInNode = 0;\n                                }\n                            } else {\n                                endNode = endElement;\n                                endOffsetInNode = 0;\n                            }\n                        }\n\n                        // Fallback to startNode if endNode not found\n                        if (!endNode && startNode) {\n                            endNode = startNode;\n                            endOffsetInNode = startOffsetInNode;\n                        }\n                    } else {\n                        endNode = startNode;\n                        endOffsetInNode = startOffsetInNode;\n                    }\n\n                    if (!startNode || !endNode) {\n                        console.error('Missing startNode or endNode. startNode:', startNode, 'endNode:', endNode);\n                        return null;\n                    }\n\n                    // Create a Range from the nodes\n                    try {\n                        var range = doc.createRange();\n\n                        if (startNode.nodeType === Node.TEXT_NODE) {\n                            var startTextLength = startNode.textContent ? startNode.textContent.length : 0;\n                            range.setStart(startNode, Math.min(startOffsetInNode, startTextLength));\n                        } else {\n                            range.setStart(startNode, 0);\n                        }\n\n                        if (endNode.nodeType === Node.TEXT_NODE) {\n                            var endTextLength = endNode.textContent ? endNode.textContent.length : 0;\n                            range.setEnd(endNode, Math.min(endOffsetInNode, endTextLength));\n                        } else {\n                            var endChildNodesLength = (endNode.childNodes && endNode.childNodes.length) || 0;\n                            range.setEnd(endNode, endChildNodesLength);\n                        }\n                    } catch (e) {\n                        console.error('Error creating range:', e);\n                        return null;\n                    }\n\n                    // Create CFI from the range\n                    var spineItem = book.spine.get(index);\n                    var cfiString = null;\n\n                    try {\n                        // Create CFI from range\n                        // epub.js CFI constructor needs the document to be in the book context\n                        var packageIndices = [6, 4];\n                        var created = false;\n\n                        // Check if range is valid\n                        if (!range || !range.startContainer || !range.endContainer) {\n                            console.error('Invalid range - missing containers');\n                            return null;\n                        }\n\n                        // Try creating CFI with base string directly (epub.js needs base)\n                        // The base format is /{packageIndex}/{spineIndex} where spineIndex is 1-based\n                        for (var p = 0; p < packageIndices.length && !created; p++) {\n                            try {\n                                var packageIndex = packageIndices[p];\n                                // epub.js uses even numbers for spine indices: 2, 4, 6, 8...\n                                // So spine index 8 (0-based) = 18 (2 * (8 + 1))\n                                var spineIndexCfi = (index + 1) * 2;\n                                var baseString = \"/\" + packageIndex + \"/\" + spineIndexCfi;\n\n                                var cfi = new ePub.CFI(range, baseString);\n                                var cfiStringWithoutBase = cfi.toString();\n\n                                // Parse it to verify\n                                var parsedCfi = new ePub.CFI(cfiStringWithoutBase);\n\n                                // If spinePos matches, use it\n                                if (parsedCfi.spinePos === index) {\n                                    cfiString = cfiStringWithoutBase;\n                                    created = true;\n                                    break;\n                                } else {\n                                    cfiString = null;\n                                }\n                            } catch (e) {\n                                cfiString = null;\n                            }\n                        }\n\n                        if (created && cfiString) {\n                            return cfiString;\n                        } else {\n                            console.error('Failed to create valid CFI with any package index');\n                            return null;\n                        }\n                    } catch (e) {\n                        console.error('Error creating CFI:', e);\n                        return null;\n                    }\n                } catch (e) {\n                    console.error('Error creating CFI for spine item', index, ':', e);\n                    return null;\n                }\n            }).catch(function (e) {\n                console.error('Error loading spine item', index, ':', e);\n                return null;\n            }).then(function (result) {\n                // If we found a match, return it immediately\n                if (result) {\n                    return result;\n                }\n                // Otherwise, check the next spine item\n                return checkSpineItemSequentially(itemIndex + 1);\n            });\n        }\n\n        // Start sequential checking from the first item\n        return checkSpineItemSequentially(0).then(function (result) {\n            if (!result) {\n                console.warn('No CFI found for XPath:', xpathString);\n            }\n            return result;\n        }).catch(function (e) {\n            console.error('Error converting XPath to CFI:', e);\n            return null;\n        });\n    } catch (e) {\n        console.error('Error parsing XPath:', e);\n        return Promise.resolve(null);\n    }\n}\n\n// Block or unblock gestures using CSS touch-action when selection is active\nfunction blockGesturesWhenSelected(block) {\n    try {\n        var styleId = 'epub-selection-block-style';\n        var existingStyle = document.getElementById(styleId);\n\n        if (block) {\n            // Block horizontal panning/swiping when selection exists\n            // Use 'pan-y' to allow vertical scrolling but block horizontal swipes\n            // Also add 'manipulation' to prevent double-tap zoom which can interfere\n            if (!existingStyle) {\n                var style = document.createElement('style');\n                style.id = styleId;\n                style.textContent = `\n          body, html, #viewer {\n            touch-action: pan-y manipulation !important;\n            -ms-touch-action: pan-y manipulation !important;\n            -webkit-touch-callout: none !important;\n            user-select: text !important;\n          }\n          body *, html *, #viewer * {\n            touch-action: pan-y manipulation !important;\n            -ms-touch-action: pan-y manipulation !important;\n            user-select: text !important;\n          }\n          iframe {\n            touch-action: pan-y manipulation !important;\n            -ms-touch-action: pan-y manipulation !important;\n            pointer-events: auto !important;\n          }\n          /* Block all horizontal gestures on iframes */\n          iframe[src], iframe[srcdoc] {\n            touch-action: pan-y manipulation !important;\n            -ms-touch-action: pan-y manipulation !important;\n          }\n        `;\n                document.head.appendChild(style);\n            }\n\n            // Function to apply touch-action to iframes\n            function applyTouchActionToIframes() {\n                try {\n                    var allIframes = document.querySelectorAll('iframe');\n                    allIframes.forEach(function (iframe) {\n                        iframe.style.touchAction = 'pan-y manipulation';\n                        iframe.style.setProperty('-ms-touch-action', 'pan-y manipulation', 'important');\n                        iframe.style.setProperty('touch-action', 'pan-y manipulation', 'important');\n                    });\n                } catch (e) {\n                    console.error('Error setting iframe touch-action:', e);\n                }\n\n                // Also try to get iframes from epub.js rendition\n                if (typeof rendition !== 'undefined' && rendition) {\n                    try {\n                        var allContents = rendition.getContents();\n                        allContents.forEach(function (contents) {\n                            try {\n                                // Get the iframe element from the parent document\n                                var iframe = contents.document.defaultView.frameElement;\n                                if (iframe && iframe.style) {\n                                    iframe.style.touchAction = 'pan-y manipulation';\n                                    iframe.style.setProperty('-ms-touch-action', 'pan-y manipulation', 'important');\n                                    iframe.style.setProperty('touch-action', 'pan-y manipulation', 'important');\n                                }\n                            } catch (e) {\n                                // Ignore errors - iframe might be sandboxed\n                            }\n                        });\n                    } catch (e) {\n                        // Ignore errors\n                    }\n                }\n            }\n\n            // Apply immediately\n            applyTouchActionToIframes();\n\n            // Watch for new iframes being added (epub.js creates them dynamically)\n            if (!window.epubIframeObserver) {\n                window.epubIframeObserver = new MutationObserver(function (mutations) {\n                    applyTouchActionToIframes();\n                });\n                window.epubIframeObserver.observe(document.body || document.documentElement, {\n                    childList: true,\n                    subtree: true\n                });\n            }\n        } else {\n            // Remove blocking when selection is cleared\n            if (existingStyle) {\n                existingStyle.remove();\n            }\n\n            // Stop observing if observer exists\n            if (window.epubIframeObserver) {\n                window.epubIframeObserver.disconnect();\n                window.epubIframeObserver = null;\n            }\n\n            // Reset iframe styles\n            try {\n                var allIframes = document.querySelectorAll('iframe');\n                allIframes.forEach(function (iframe) {\n                    iframe.style.touchAction = '';\n                    iframe.style.removeProperty('-ms-touch-action');\n                    iframe.style.removeProperty('touch-action');\n                });\n            } catch (e) {\n                // Ignore errors\n            }\n\n            // Reset epub.js iframe styles\n            if (typeof rendition !== 'undefined' && rendition) {\n                try {\n                    var allContents = rendition.getContents();\n                    allContents.forEach(function (contents) {\n                        try {\n                            var iframe = contents.document.defaultView.frameElement;\n                            if (iframe && iframe.style) {\n                                iframe.style.touchAction = '';\n                                iframe.style.removeProperty('-ms-touch-action');\n                                iframe.style.removeProperty('touch-action');\n                            }\n                        } catch (e) {\n                            // Ignore errors\n                        }\n                    });\n                } catch (e) {\n                    // Ignore errors\n                }\n            }\n        }\n    } catch (e) {\n        console.error('Error blocking gestures:', e);\n    }\n}\n\n// Check selection after long press (for iPad support)\nfunction checkSelectionAfterLongPress() {\n    try {\n        // Check all content frames\n        if (typeof rendition !== 'undefined' && rendition) {\n            var allContents = rendition.getContents();\n            allContents.forEach(function (contents, idx) {\n                try {\n                    var selection = contents.window.getSelection();\n                    if (selection && selection.rangeCount > 0) {\n                        var range = selection.getRangeAt(0);\n                        var text = selection.toString();\n                        if (text && range && !range.collapsed) {\n                            // Try to get CFI\n                            if (typeof contents.cfiFromRange === 'function') {\n                                try {\n                                    var cfiRange = contents.cfiFromRange(range);\n                                    if (cfiRange) {\n                                        // Store this CFI to track changes\n                                        window.lastProcessedCfi = cfiRange.toString();\n\n                                        // Call sendSelectionData if it exists (it should be globally available)\n                                        if (typeof window.sendSelectionData === 'function') {\n                                            try {\n                                                window.sendSelectionData(cfiRange, contents);\n                                            } catch (e) {\n                                                // Fallback to direct handler call with manual rect calculation\n                                                try {\n                                                    var rect = null;\n                                                    if (range) {\n                                                        var clientRect = range.getBoundingClientRect();\n                                                        var webViewWidth = window.innerWidth;\n                                                        var webViewHeight = window.innerHeight;\n                                                        var iframe = contents.document.defaultView.frameElement;\n                                                        if (iframe) {\n                                                            var iframeRect = iframe.getBoundingClientRect();\n                                                            var absoluteLeft = iframeRect.left + clientRect.left;\n                                                            var absoluteTop = iframeRect.top + clientRect.top;\n                                                            rect = {\n                                                                left: absoluteLeft / webViewWidth,\n                                                                top: absoluteTop / webViewHeight,\n                                                                width: clientRect.width / webViewWidth,\n                                                                height: clientRect.height / webViewHeight,\n                                                                contentHeight: webViewHeight\n                                                            };\n                                                        }\n                                                    }\n                                                    window.flutter_inappwebview.callHandler('selection', cfiRange.toString(), text, rect, null);\n                                                } catch (e2) {\n                                                    window.flutter_inappwebview.callHandler('selection', cfiRange.toString(), text, null, null);\n                                                }\n                                            }\n                                        } else {\n                                            // Try to get rect manually as fallback\n                                            try {\n                                                var rect = null;\n                                                if (range) {\n                                                    var clientRect = range.getBoundingClientRect();\n                                                    var webViewWidth = window.innerWidth;\n                                                    var webViewHeight = window.innerHeight;\n                                                    var iframe = contents.document.defaultView.frameElement;\n                                                    if (iframe) {\n                                                        var iframeRect = iframe.getBoundingClientRect();\n                                                        var absoluteLeft = iframeRect.left + clientRect.left;\n                                                        var absoluteTop = iframeRect.top + clientRect.top;\n                                                        rect = {\n                                                            left: absoluteLeft / webViewWidth,\n                                                            top: absoluteTop / webViewHeight,\n                                                            width: clientRect.width / webViewWidth,\n                                                            height: clientRect.height / webViewHeight,\n                                                            contentHeight: webViewHeight\n                                                        };\n                                                    }\n                                                }\n                                                window.flutter_inappwebview.callHandler('selection', cfiRange.toString(), text, rect, null);\n                                            } catch (e) {\n                                                window.flutter_inappwebview.callHandler('selection', cfiRange.toString(), text, null, null);\n                                            }\n                                        }\n                                    }\n                                } catch (e) {\n                                    // Ignore errors\n                                }\n                            }\n                        }\n                    }\n                } catch (e) {\n                    // Ignore errors\n                }\n            });\n\n            // Also check parent window\n            try {\n                var parentSel = window.getSelection();\n                if (parentSel && parentSel.rangeCount > 0) {\n                    var parentText = parentSel.toString();\n                    if (parentText) {\n                        // Try to match to a content frame\n                        allContents.forEach(function (contents, idx) {\n                            try {\n                                var range = parentSel.getRangeAt(0);\n                                if (range && !range.collapsed && typeof contents.cfiFromRange === 'function') {\n                                    var cfiRange = contents.cfiFromRange(range);\n                                    if (cfiRange) {\n                                        if (typeof window.sendSelectionData === 'function') {\n                                            window.sendSelectionData(cfiRange, contents);\n                                        } else {\n                                            window.flutter_inappwebview.callHandler('selection', cfiRange.toString(), parentText, null, null);\n                                        }\n                                    }\n                                }\n                            } catch (e) {\n                                // Try next frame\n                            }\n                        });\n                    }\n                }\n            } catch (e) {\n                // Ignore errors\n            }\n        }\n    } catch (e) {\n        // Ignore errors\n    }\n}\n\n// Check selection periodically (for tracking selection changes when handles are dragged)\nfunction checkSelectionPeriodically() {\n    try {\n        if (typeof rendition !== 'undefined' && rendition) {\n            var allContents = rendition.getContents();\n            var foundSelection = false;\n            allContents.forEach(function (contents, idx) {\n                try {\n                    var selection = contents.window.getSelection();\n                    if (selection && selection.rangeCount > 0) {\n                        var range = selection.getRangeAt(0);\n                        var text = selection.toString();\n                        if (text && range && !range.collapsed) {\n                            foundSelection = true;\n                            // Check if this is a new/different selection\n                            if (typeof contents.cfiFromRange === 'function') {\n                                try {\n                                    var cfiRange = contents.cfiFromRange(range);\n                                    if (cfiRange) {\n                                        var cfiString = cfiRange.toString();\n                                        // Only process if CFI changed (selection was modified)\n                                        if (cfiString !== window.lastProcessedCfi) {\n                                            window.lastProcessedCfi = cfiString;\n                                            if (typeof window.sendSelectionData === 'function') {\n                                                window.sendSelectionData(cfiRange, contents);\n                                            }\n                                        }\n                                    }\n                                } catch (e) {\n                                    // Ignore errors\n                                }\n                            }\n                        }\n                    }\n                } catch (e) {\n                    // Ignore errors\n                }\n            });\n\n            // Also check parent window\n            try {\n                var parentSel = window.getSelection();\n                if (parentSel && parentSel.rangeCount > 0) {\n                    var parentText = parentSel.toString();\n                    if (parentText) {\n                        foundSelection = true;\n                        var allContents = rendition.getContents();\n                        allContents.forEach(function (contents, idx) {\n                            try {\n                                var range = parentSel.getRangeAt(0);\n                                if (range && !range.collapsed && typeof contents.cfiFromRange === 'function') {\n                                    var cfiRange = contents.cfiFromRange(range);\n                                    if (cfiRange) {\n                                        var cfiString = cfiRange.toString();\n                                        if (cfiString !== window.lastProcessedCfi) {\n                                            window.lastProcessedCfi = cfiString;\n                                            if (typeof window.sendSelectionData === 'function') {\n                                                window.sendSelectionData(cfiRange, contents);\n                                            }\n                                        }\n                                    }\n                                }\n                            } catch (e) {\n                                // Try next frame\n                            }\n                        });\n                    }\n                }\n            } catch (e) {\n                // Ignore\n            }\n        }\n    } catch (e) {\n        // Ignore errors\n    }\n}\n\n// Check if selection still exists and re-apply blocking if needed\nfunction checkSelectionAndReapplyBlocking() {\n    try {\n        // Check if selection still exists\n        var hasSelection = false;\n\n        if (typeof rendition !== 'undefined' && rendition) {\n            var allContents = rendition.getContents();\n            for (var i = 0; i < allContents.length; i++) {\n                try {\n                    var contents = allContents[i];\n                    if (contents.window && contents.window.getSelection) {\n                        var selection = contents.window.getSelection();\n                        if (selection && selection.rangeCount > 0) {\n                            var range = selection.getRangeAt(0);\n                            var text = selection.toString();\n                            if ((text && text.length > 0) || (range && !range.collapsed)) {\n                                hasSelection = true;\n                                break;\n                            }\n                        }\n                    }\n                } catch (e) {\n                    // Ignore errors\n                }\n            }\n        }\n\n        // Also check parent window\n        if (!hasSelection && window.getSelection) {\n            var parentSel = window.getSelection();\n            if (parentSel && parentSel.rangeCount > 0) {\n                var parentRange = parentSel.getRangeAt(0);\n                var parentText = parentSel.toString();\n                if ((parentText && parentText.length > 0) || (parentRange && !parentRange.collapsed)) {\n                    hasSelection = true;\n                }\n            }\n        }\n\n        // If selection exists, ensure blocking is still active\n        if (hasSelection) {\n            var styleId = 'epub-selection-block-style';\n            var existingStyle = document.getElementById(styleId);\n\n            if (!existingStyle) {\n                // Re-apply blocking if it was removed - use 'pan-y manipulation' to block horizontal swipes\n                var style = document.createElement('style');\n                style.id = styleId;\n                style.textContent = `\n          body, html, #viewer {\n            touch-action: pan-y manipulation !important;\n            -ms-touch-action: pan-y manipulation !important;\n            -webkit-touch-callout: none !important;\n            user-select: text !important;\n          }\n          body *, html *, #viewer * {\n            touch-action: pan-y manipulation !important;\n            -ms-touch-action: pan-y manipulation !important;\n            user-select: text !important;\n          }\n          iframe {\n            touch-action: pan-y manipulation !important;\n            -ms-touch-action: pan-y manipulation !important;\n            pointer-events: auto !important;\n          }\n          iframe[src], iframe[srcdoc] {\n            touch-action: pan-y manipulation !important;\n            -ms-touch-action: pan-y manipulation !important;\n          }\n        `;\n                document.head.appendChild(style);\n            }\n\n            // Re-apply to iframes\n            try {\n                var allIframes = document.querySelectorAll('iframe');\n                allIframes.forEach(function (iframe) {\n                    iframe.style.touchAction = 'pan-y manipulation';\n                    iframe.style.setProperty('-ms-touch-action', 'pan-y manipulation', 'important');\n                    iframe.style.setProperty('touch-action', 'pan-y manipulation', 'important');\n                });\n            } catch (e) {\n                // Ignore errors\n            }\n        } else {\n            // No selection, stop monitoring\n            return 'no-selection';\n        }\n    } catch (e) {\n        console.error('Error checking selection:', e);\n    }\n}\n\nfunction detectSwipe(el, func) {\n    swipe_det = new Object();\n    swipe_det.sX = 0;\n    swipe_det.sY = 0;\n    swipe_det.eX = 0;\n    swipe_det.eY = 0;\n    swipe_det.blocked = false; // Track if swipe should be blocked\n    swipe_det.hasMoved = false; // Track if touch has moved\n    swipe_det.touchStartTime = null; // Track when touch started\n    var min_x = 50;  //min x swipe for horizontal swipe\n    var max_x = 40;  //max x difference for vertical swipe\n    var min_y = 40;  //min y swipe for vertical swipe\n    var max_y = 50;  //max y difference for horizontal swipe\n    var direc = \"\";\n    ele = el\n    ele.addEventListener('touchstart', function (e) {\n        // Check if selection exists at start of gesture\n        if (hasActiveSelection()) {\n            // Store position and time to detect if it's a tap or swipe\n            swipe_det.blocked = false; // Don't block yet - wait to see if it's a tap\n            swipe_det.hasMoved = false;\n            swipe_det.touchStartTime = Date.now();\n            if (e.touches && e.touches.length > 0) {\n                var t = e.touches[0];\n                swipe_det.sX = t.screenX;\n                swipe_det.sY = t.screenY;\n                swipe_det.eX = swipe_det.sX;\n                swipe_det.eY = swipe_det.sY;\n            }\n            // Don't preventDefault yet - allow taps to deselect\n        } else {\n            swipe_det.blocked = false;\n            swipe_det.hasMoved = false;\n            swipe_det.touchStartTime = Date.now();\n            var t = e.touches[0];\n            swipe_det.sX = t.screenX;\n            swipe_det.sY = t.screenY;\n            swipe_det.eX = swipe_det.sX;\n            swipe_det.eY = swipe_det.sY;\n        }\n    }, { capture: true, passive: false }); // Use options object with passive: false\n    ele.addEventListener('touchmove', function (e) {\n        // If selection exists, check if it's a swipe\n        if (hasActiveSelection()) {\n            var t = e.touches[0];\n            swipe_det.eX = t.screenX;\n            swipe_det.eY = t.screenY;\n\n            var deltaX = Math.abs(swipe_det.eX - swipe_det.sX);\n            var deltaY = Math.abs(swipe_det.eY - swipe_det.sY);\n\n            // If there's significant movement, it's a swipe - block it\n            if (deltaX > 10 || deltaY > 10) {\n                swipe_det.hasMoved = true;\n                // Block horizontal swipes\n                if (deltaX > 30 && deltaX > deltaY * 1.5) {\n                    swipe_det.blocked = true;\n                    e.preventDefault();\n                    e.stopPropagation();\n                    return false;\n                }\n                // Block significant horizontal movement\n                if (deltaX > 50) {\n                    swipe_det.blocked = true;\n                    e.preventDefault();\n                    e.stopPropagation();\n                    return false;\n                }\n            }\n        } else {\n            // Only prevent default if we're actually tracking a swipe\n            e.preventDefault();\n            var t = e.touches[0];\n            swipe_det.eX = t.screenX;\n            swipe_det.eY = t.screenY;\n        }\n    }, { capture: true, passive: false }); // Use options object with passive: false\n    ele.addEventListener('touchend', function (e) {\n        // If selection exists, check if it was a tap or swipe\n        if (hasActiveSelection()) {\n            if (swipe_det.touchStartTime !== null) {\n                var deltaX = Math.abs(swipe_det.eX - swipe_det.sX);\n                var deltaY = Math.abs(swipe_det.eY - swipe_det.sY);\n                var touchDuration = Date.now() - swipe_det.touchStartTime;\n\n                // If minimal movement and short duration, it's a tap - allow it to deselect\n                if (!swipe_det.hasMoved && deltaX < 10 && deltaY < 10 && touchDuration < 300) {\n                    // Don't preventDefault - allow tap to deselect\n                } else if (deltaX > 30 && deltaX > deltaY * 1.5) {\n                    // It was a horizontal swipe - block it\n                    swipe_det.blocked = true;\n                    e.preventDefault();\n                    e.stopPropagation();\n                    return false;\n                } else if (deltaX > 50) {\n                    // Significant horizontal movement - block it\n                    swipe_det.blocked = true;\n                    e.preventDefault();\n                    e.stopPropagation();\n                    return false;\n                }\n            }\n            // If it was a tap, don't preventDefault\n            swipe_det.blocked = false;\n            return;\n        }\n\n        // Don't process swipe if it was blocked\n        if (swipe_det.blocked) {\n            swipe_det.blocked = false;\n            swipe_det.hasMoved = false;\n            swipe_det.touchStartTime = null;\n            return;\n        }\n\n        //horizontal detection\n        if ((((swipe_det.eX - min_x > swipe_det.sX) || (swipe_det.eX + min_x < swipe_det.sX)) && ((swipe_det.eY < swipe_det.sY + max_y) && (swipe_det.sY > swipe_det.eY - max_y)))) {\n            if (swipe_det.eX > swipe_det.sX) direc = \"r\";\n            else direc = \"l\";\n        }\n        //vertical detection\n        if ((((swipe_det.eY - min_y > swipe_det.sY) || (swipe_det.eY + min_y < swipe_det.sY)) && ((swipe_det.eX < swipe_det.sX + max_x) && (swipe_det.sX > swipe_det.eX - max_x)))) {\n            if (swipe_det.eY > swipe_det.sY) direc = \"d\";\n            else direc = \"u\";\n        }\n\n        if (direc != \"\") {\n            if (typeof func == 'function') func(el, direc);\n        }\n        direc = \"\";\n        swipe_det.blocked = false;\n        swipe_det.hasMoved = false;\n        swipe_det.touchStartTime = null;\n    }, { capture: true, passive: false }); // Use options object with passive: false\n}"
        }
    ]
}