{
    "sourceFile": "lib/assets/webpage/html/epubView.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 23,
            "patches": [
                {
                    "date": 1762657250924,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762658368720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -296,18 +296,33 @@\n }\n \n // adds underline with optional color and style (solid/dashed)\n function addUnderLine(cfiString, color, isDashed) {\n-  var styles = { \"stroke\": color || \"black\" };\n+  var underlineColor = color || \"black\";\n \n-  // Add dash style if requested\n-  if (isDashed) {\n-    styles[\"stroke-dasharray\"] = \"5,3\"; // 5px dash, 3px gap\n+  // Create the underline annotation\n+  var annotation = rendition.annotations.underline(cfiString, {}, (e) => {\n+    // console.log(\"underline clicked\", e.target);\n+  }, \"ul\");\n+\n+  // Customize the line style after creation\n+  if (annotation && annotation.mark && annotation.mark.element) {\n+    var lines = annotation.mark.element.querySelectorAll('line');\n+    lines.forEach(function (line) {\n+      line.setAttribute('stroke', underlineColor);\n+      if (isDashed) {\n+        line.setAttribute('stroke-dasharray', '5,3'); // 5px dash, 3px gap\n+      }\n+    });\n+\n+    // Ensure rect elements have no stroke (to avoid the box)\n+    var rects = annotation.mark.element.querySelectorAll('rect');\n+    rects.forEach(function (rect) {\n+      rect.setAttribute('stroke', 'none');\n+    });\n   }\n \n-  rendition.annotations.underline(cfiString, {}, (e) => {\n-    // console.log(\"underline clicked\", e.target);\n-  }, \"ul\", styles);\n+  return annotation;\n }\n \n function addMark(cfiString) {\n   rendition.annotations.mark(cfiString)\n"
                },
                {
                    "date": 1762658627933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -305,21 +305,23 @@\n   }, \"ul\");\n \n   // Customize the line style after creation\n   if (annotation && annotation.mark && annotation.mark.element) {\n+    // Remove all rect elements (we only want the line, not the box)\n+    var rects = annotation.mark.element.querySelectorAll('rect');\n+    rects.forEach(function (rect) {\n+      rect.remove();\n+    });\n+\n+    // Customize the line elements\n     var lines = annotation.mark.element.querySelectorAll('line');\n     lines.forEach(function (line) {\n       line.setAttribute('stroke', underlineColor);\n+      line.setAttribute('stroke-opacity', '1'); // Fully opaque, no transparency\n       if (isDashed) {\n         line.setAttribute('stroke-dasharray', '5,3'); // 5px dash, 3px gap\n       }\n     });\n-\n-    // Ensure rect elements have no stroke (to avoid the box)\n-    var rects = annotation.mark.element.querySelectorAll('rect');\n-    rects.forEach(function (rect) {\n-      rect.setAttribute('stroke', 'none');\n-    });\n   }\n \n   return annotation;\n }\n"
                },
                {
                    "date": 1762658896387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,497 @@\n+var book = ePub();\n+var rendition;\n+var displayed;\n+var chapters = []\n+var clearSelectionOnPageChange = true; // Global flag for selection clearing behavior\n+\n+\n+\n+function loadBook(data, cfi, manager, flow, spread, snap, allowScriptedContent, direction, useCustomSwipe, backgroundColor, foregroundColor, fontSize, clearSelectionOnNav) {\n+  // Store the clearSelectionOnPageChange setting\n+  clearSelectionOnPageChange = clearSelectionOnNav !== undefined ? clearSelectionOnNav : true;\n+  var viewportHeight = window.innerHeight;\n+  document.getElementById('viewer').style.height = viewportHeight;\n+  var uint8Array = new Uint8Array(data)\n+  book.open(uint8Array,)\n+  rendition = book.renderTo(\"viewer\", {\n+    manager: manager,\n+    flow: flow,\n+    // method: \"continuous\",\n+    spread: spread,\n+    width: \"100vw\",\n+    height: \"100vh\",\n+    snap: snap && !useCustomSwipe,\n+    allowScriptedContent: allowScriptedContent,\n+    defaultDirection: direction\n+  });\n+\n+  if (cfi) {\n+    displayed = rendition.display(cfi)\n+  } else {\n+    displayed = rendition.display()\n+  }\n+\n+  rendition.on(\"displayed\", function (renderer) {\n+    window.flutter_inappwebview.callHandler('displayed');\n+  });\n+\n+  // Selection state tracking\n+  var selectionTimeout = null;\n+  var isSelecting = false;\n+  var lastCfiRange = null;\n+\n+  // Handle selection clearing and changes\n+  rendition.hooks.content.register(function (contents) {\n+    contents.window.document.addEventListener('selectionchange', function () {\n+      var selection = contents.window.getSelection();\n+      var selectedText = selection.toString();\n+\n+      if (!selectedText) {\n+        // Selection cleared\n+        isSelecting = false;\n+        lastCfiRange = null;\n+        if (selectionTimeout) {\n+          clearTimeout(selectionTimeout);\n+          selectionTimeout = null;\n+        }\n+        window.flutter_inappwebview.callHandler('selectionCleared');\n+      } else if (isSelecting) {\n+        // Selection is being modified (dragging handles)\n+        // Notify Flutter to hide the widget\n+        window.flutter_inappwebview.callHandler('selectionChanging');\n+\n+        // Clear existing timeout\n+        if (selectionTimeout) {\n+          clearTimeout(selectionTimeout);\n+        }\n+\n+        // Set timeout to detect when dragging stops\n+        selectionTimeout = setTimeout(function () {\n+          // Selection has stabilized, send the final selection\n+          if (lastCfiRange) {\n+            sendSelectionData(lastCfiRange, contents);\n+          }\n+          isSelecting = false;\n+        }, 300); // 300ms debounce\n+      }\n+    });\n+  });\n+\n+  book.loaded.navigation.then(function (toc) {\n+    chapters = parseChapters(toc)\n+    window.flutter_inappwebview.callHandler('chapters');\n+  })\n+\n+  rendition.on(\"rendered\", function () {\n+    window.flutter_inappwebview.callHandler('rendered');\n+  })\n+\n+  // Function to calculate and send selection data\n+  function sendSelectionData(cfiRange, contents) {\n+    book.getRange(cfiRange).then(function (range) {\n+      var selectedText = range.toString();\n+\n+      try {\n+        // Get selection coordinates\n+        var selection = contents.window.getSelection();\n+        var rect = null;\n+\n+        if (selection && selection.rangeCount > 0) {\n+          // Get the range and its client rect (relative to iframe viewport)\n+          var selRange = selection.getRangeAt(0);\n+          var clientRect = selRange.getBoundingClientRect();\n+\n+          // Get the WebView dimensions (parent window)\n+          var webViewWidth = window.innerWidth;\n+          var webViewHeight = window.innerHeight;\n+\n+          // Get the iframe element in the parent document\n+          var iframe = contents.document.defaultView.frameElement;\n+          var iframeRect = iframe.getBoundingClientRect();\n+\n+          // Calculate absolute position in WebView (iframe offset + selection position)\n+          var absoluteLeft = iframeRect.left + clientRect.left;\n+          var absoluteTop = iframeRect.top + clientRect.top;\n+\n+          // Normalize to 0-1 range relative to WebView dimensions\n+          rect = {\n+            left: absoluteLeft / webViewWidth,\n+            top: absoluteTop / webViewHeight,\n+            width: clientRect.width / webViewWidth,\n+            height: clientRect.height / webViewHeight,\n+            contentHeight: webViewHeight\n+          };\n+        }\n+\n+        var args = [cfiRange.toString(), selectedText, rect];\n+        window.flutter_inappwebview.callHandler('selection', ...args);\n+      } catch (e) {\n+        // Still send the selection without coordinates if there's an error\n+        var args = [cfiRange.toString(), selectedText, null];\n+        window.flutter_inappwebview.callHandler('selection', ...args);\n+      }\n+    });\n+  }\n+\n+  ///text selection callback\n+  rendition.on(\"selected\", function (cfiRange, contents) {\n+    lastCfiRange = cfiRange;\n+\n+    if (!isSelecting) {\n+      // Initial selection - send immediately\n+      isSelecting = true;\n+      sendSelectionData(cfiRange, contents);\n+    }\n+    // If already selecting, the selectionchange handler will debounce it\n+  });\n+\n+  //book location changes callback\n+  rendition.on(\"relocated\", function (location) {\n+    // Clear selection when navigating to a new page (if enabled)\n+    if (clearSelectionOnPageChange && (isSelecting || lastCfiRange)) {\n+      isSelecting = false;\n+      lastCfiRange = null;\n+      if (selectionTimeout) {\n+        clearTimeout(selectionTimeout);\n+        selectionTimeout = null;\n+      }\n+\n+      // Clear the actual browser selection across all iframe contents\n+      rendition.getContents().forEach(function (contents) {\n+        try {\n+          if (contents.window.getSelection) {\n+            contents.window.getSelection().removeAllRanges();\n+          }\n+        } catch (e) {\n+          // Ignore errors if iframe is not accessible\n+        }\n+      });\n+\n+      // Notify Flutter that selection was cleared\n+      window.flutter_inappwebview.callHandler('selectionCleared');\n+    }\n+\n+    var percent = location.start.percentage;\n+    var location = {\n+      startCfi: location.start.cfi,\n+      endCfi: location.end.cfi,\n+      progress: percent\n+    }\n+    var args = [location]\n+    window.flutter_inappwebview.callHandler('relocated', ...args);\n+  });\n+\n+  rendition.on('displayError', function (e) {\n+    window.flutter_inappwebview.callHandler('displayError');\n+  })\n+\n+  rendition.on('markClicked', function (cfiRange) {\n+    var args = [cfiRange.toString()]\n+    window.flutter_inappwebview.callHandler('markClicked', ...args);\n+  })\n+\n+  book.ready.then(function () {\n+    book.locations.generate(1600).then(() => {\n+      if (cfi) {\n+        rendition.display(cfi)\n+      }\n+      window.flutter_inappwebview.callHandler('locationLoaded');\n+    })\n+  })\n+\n+  rendition.hooks.content.register((contents) => {\n+\n+    if (useCustomSwipe) {\n+      const el = contents.document.documentElement;\n+\n+      if (el) {\n+        // console.log('EPUB_TEST_HOOK_IF')\n+        detectSwipe(el, function (el, direction) {\n+          // console.log(\"EPUB_TEST_DIR\"+direction.toString())\n+\n+          if (direction == 'l') {\n+            rendition.next()\n+          }\n+          if (direction == 'r') {\n+            rendition.prev()\n+          }\n+        });\n+      }\n+    }\n+  });\n+  rendition.themes.fontSize(fontSize + \"px\");\n+  //set background and foreground color\n+  updateTheme(backgroundColor, foregroundColor);\n+}\n+\n+window.addEventListener(\"flutterInAppWebViewPlatformReady\", function (event) {\n+  window.flutter_inappwebview.callHandler('readyToLoad');\n+});\n+\n+//move to next page\n+function next() {\n+  rendition.next()\n+}\n+\n+//move to previous page\n+function previous() {\n+  rendition.prev()\n+}\n+\n+//move to given cfi location\n+function toCfi(cfi) {\n+  rendition.display(cfi)\n+}\n+\n+//get all chapters\n+function getChapters() {\n+  return chapters;\n+}\n+\n+async function getBookInfo() {\n+  const metadata = book.package.metadata;\n+  metadata['coverImage'] = book.cover;\n+  console.log(\"getBookInfo\", await book.coverUrl());\n+  return metadata;\n+}\n+\n+function getCurrentLocation() {\n+  var percent = rendition.location.start.percentage;\n+  // var percentage = Math.floor(percent * 100);\n+  var location = {\n+    startCfi: rendition.location.start.cfi,\n+    endCfi: rendition.location.end.cfi,\n+    progress: percent\n+  }\n+  return location;\n+}\n+\n+///parsing chapters and subitems recursively\n+var parseChapters = function (toc) {\n+  var chapters = []\n+  toc.forEach(function (chapter) {\n+    chapters.push({\n+      title: chapter.label,\n+      href: chapter.href,\n+      id: chapter.id,\n+      subitems: parseChapters(chapter.subitems)\n+    })\n+  })\n+  return chapters;\n+}\n+\n+function searchInBook(query) {\n+  search(query).then(function (data) {\n+    var args = [data]\n+    window.flutter_inappwebview.callHandler('search', ...args);\n+  })\n+}\n+\n+\n+// adds highlight with given color\n+function addHighlight(cfiRange, color, opacity) {\n+  rendition.annotations.highlight(cfiRange, {}, (e) => {\n+    // console.log(\"highlight clicked\", e.target);\n+  }, \"hl\", { \"fill\": color, \"fill-opacity\": '0.3', \"mix-blend-mode\": \"multiply\" });\n+}\n+\n+// adds underline with optional color and style (solid/dashed)\n+function addUnderLine(cfiString, color, isDashed) {\n+  var underlineColor = color || \"black\";\n+\n+  // Create the underline annotation\n+  var annotation = rendition.annotations.underline(cfiString, {}, (e) => {\n+    // console.log(\"underline clicked\", e.target);\n+  }, \"ul\");\n+\n+  // Use setTimeout to ensure DOM elements are fully created\n+  setTimeout(function () {\n+    if (annotation && annotation.mark && annotation.mark.element) {\n+      // Remove all rect elements (we only want the line, not the box)\n+      var rects = annotation.mark.element.querySelectorAll('rect');\n+      rects.forEach(function (rect) {\n+        rect.remove();\n+      });\n+\n+      // Customize the line elements with !important styles\n+      var lines = annotation.mark.element.querySelectorAll('line');\n+      lines.forEach(function (line) {\n+        line.setAttribute('stroke', underlineColor);\n+        line.setAttribute('stroke-opacity', '1');\n+        line.setAttribute('opacity', '1');\n+        line.style.setProperty('stroke', underlineColor, 'important');\n+        line.style.setProperty('stroke-opacity', '1', 'important');\n+        line.style.setProperty('opacity', '1', 'important');\n+        if (isDashed) {\n+          line.setAttribute('stroke-dasharray', '5,3');\n+          line.style.setProperty('stroke-dasharray', '5,3', 'important');\n+        }\n+      });\n+    }\n+  }, 10);\n+\n+  return annotation;\n+}\n+\n+function addMark(cfiString) {\n+  rendition.annotations.mark(cfiString)\n+}\n+\n+function removeHighlight(cfiString) {\n+  rendition.annotations.remove(cfiString, \"highlight\");\n+}\n+\n+function removeUnderLine(cfiString) {\n+  rendition.annotations.remove(cfiString, \"underline\");\n+}\n+\n+function removeMark(cfiString) {\n+  rendition.annotations.remove(cfiString, \"mark\");\n+}\n+\n+function toProgress(progress) {\n+  var cfi = book.locations.cfiFromPercentage(progress);\n+  rendition.display(cfi);\n+}\n+\n+\n+function search(q) {\n+  return Promise.all(\n+    book.spine.spineItems.map(item => item.load(book.load.bind(book)).then(item.find.bind(item, q)).finally(item.unload.bind(item)))\n+  ).then(results => Promise.resolve([].concat.apply([], results)));\n+};\n+\n+function setFontSize(fontSize) {\n+  rendition.themes.default({\n+    p: {\n+      // \"margin\": '10px',\n+      \"font-size\": `${fontSize}px`\n+    }\n+  });\n+}\n+\n+function setSpread(spread) {\n+  rendition.spread(spread);\n+}\n+\n+function setFlow(flow) {\n+  rendition.flow(flow);\n+}\n+\n+function setManager(manager) {\n+  rendition.manager(manager);\n+}\n+\n+function setFontSize(fontSize) {\n+  rendition.themes.fontSize(`${fontSize}px`);\n+  rendition.reportLocation();\n+}\n+\n+//get current page text\n+function getCurrentPageText() {\n+  var startCfi = rendition.location.start.cfi\n+  var endCfi = rendition.location.end.cfi\n+  var cfiRange = makeRangeCfi(startCfi, endCfi)\n+  book.getRange(cfiRange).then(function (range) {\n+    var text = range.toString();\n+    var args = [text, cfiRange]\n+    window.flutter_inappwebview.callHandler('epubText', ...args);\n+  })\n+}\n+\n+//get text from a range\n+function getTextFromCfi(startCfi, endCfi) {\n+  var cfiRange = makeRangeCfi(startCfi, endCfi)\n+  book.getRange(cfiRange).then(function (range) {\n+    var text = range.toString();\n+    var args = [text, cfiRange]\n+    window.flutter_inappwebview.callHandler('epubText', ...args);\n+  })\n+}\n+\n+///update theme\n+function updateTheme(backgroundColor, foregroundColor) {\n+  if (backgroundColor && foregroundColor) {\n+    rendition.themes.register(\"dark\", { \"body\": { \"background\": backgroundColor, \"color\": foregroundColor } });\n+    rendition.themes.select(\"dark\");\n+  }\n+}\n+\n+const makeRangeCfi = (a, b) => {\n+  const CFI = new ePub.CFI()\n+  const start = CFI.parse(a), end = CFI.parse(b)\n+  const cfi = {\n+    range: true,\n+    base: start.base,\n+    path: {\n+      steps: [],\n+      terminal: null\n+    },\n+    start: start.path,\n+    end: end.path\n+  }\n+  const len = cfi.start.steps.length\n+  for (let i = 0; i < len; i++) {\n+    if (CFI.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n+      if (i == len - 1) {\n+        // Last step is equal, check terminals\n+        if (cfi.start.terminal === cfi.end.terminal) {\n+          // CFI's are equal\n+          cfi.path.steps.push(cfi.start.steps[i])\n+          // Not a range\n+          cfi.range = false\n+        }\n+      } else cfi.path.steps.push(cfi.start.steps[i])\n+    } else break\n+  }\n+  cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length)\n+  cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length)\n+\n+  return 'epubcfi(' + CFI.segmentString(cfi.base)\n+    + '!' + CFI.segmentString(cfi.path)\n+    + ',' + CFI.segmentString(cfi.start)\n+    + ',' + CFI.segmentString(cfi.end)\n+    + ')'\n+}\n+\n+function detectSwipe(el, func) {\n+  swipe_det = new Object();\n+  swipe_det.sX = 0;\n+  swipe_det.sY = 0;\n+  swipe_det.eX = 0;\n+  swipe_det.eY = 0;\n+  var min_x = 50;  //min x swipe for horizontal swipe\n+  var max_x = 40;  //max x difference for vertical swipe\n+  var min_y = 40;  //min y swipe for vertical swipe\n+  var max_y = 50;  //max y difference for horizontal swipe\n+  var direc = \"\";\n+  ele = el\n+  ele.addEventListener('touchstart', function (e) {\n+    var t = e.touches[0];\n+    swipe_det.sX = t.screenX;\n+    swipe_det.sY = t.screenY;\n+  }, false);\n+  ele.addEventListener('touchmove', function (e) {\n+    e.preventDefault();\n+    var t = e.touches[0];\n+    swipe_det.eX = t.screenX;\n+    swipe_det.eY = t.screenY;\n+  }, false);\n+  ele.addEventListener('touchend', function (e) {\n+    //horizontal detection\n+    if ((((swipe_det.eX - min_x > swipe_det.sX) || (swipe_det.eX + min_x < swipe_det.sX)) && ((swipe_det.eY < swipe_det.sY + max_y) && (swipe_det.sY > swipe_det.eY - max_y)))) {\n+      if (swipe_det.eX > swipe_det.sX) direc = \"r\";\n+      else direc = \"l\";\n+    }\n+    //vertical detection\n+    if ((((swipe_det.eY - min_y > swipe_det.sY) || (swipe_det.eY + min_y < swipe_det.sY)) && ((swipe_det.eX < swipe_det.sX + max_x) && (swipe_det.sX > swipe_det.eX - max_x)))) {\n+      if (swipe_det.eY > swipe_det.sY) direc = \"d\";\n+      else direc = \"u\";\n+    }\n+\n+    if (direc != \"\") {\n+      if (typeof func == 'function') func(el, direc);\n+    }\n+    direc = \"\";\n+  }, false);\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1762658912758,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -493,495 +493,5 @@\n       if (typeof func == 'function') func(el, direc);\n     }\n     direc = \"\";\n   }, false);\n-}\n-var book = ePub();\n-var rendition;\n-var displayed;\n-var chapters = []\n-var clearSelectionOnPageChange = true; // Global flag for selection clearing behavior\n-\n-\n-\n-function loadBook(data, cfi, manager, flow, spread, snap, allowScriptedContent, direction, useCustomSwipe, backgroundColor, foregroundColor, fontSize, clearSelectionOnNav) {\n-  // Store the clearSelectionOnPageChange setting\n-  clearSelectionOnPageChange = clearSelectionOnNav !== undefined ? clearSelectionOnNav : true;\n-  var viewportHeight = window.innerHeight;\n-  document.getElementById('viewer').style.height = viewportHeight;\n-  var uint8Array = new Uint8Array(data)\n-  book.open(uint8Array,)\n-  rendition = book.renderTo(\"viewer\", {\n-    manager: manager,\n-    flow: flow,\n-    // method: \"continuous\",\n-    spread: spread,\n-    width: \"100vw\",\n-    height: \"100vh\",\n-    snap: snap && !useCustomSwipe,\n-    allowScriptedContent: allowScriptedContent,\n-    defaultDirection: direction\n-  });\n-\n-  if (cfi) {\n-    displayed = rendition.display(cfi)\n-  } else {\n-    displayed = rendition.display()\n-  }\n-\n-  rendition.on(\"displayed\", function (renderer) {\n-    window.flutter_inappwebview.callHandler('displayed');\n-  });\n-\n-  // Selection state tracking\n-  var selectionTimeout = null;\n-  var isSelecting = false;\n-  var lastCfiRange = null;\n-\n-  // Handle selection clearing and changes\n-  rendition.hooks.content.register(function (contents) {\n-    contents.window.document.addEventListener('selectionchange', function () {\n-      var selection = contents.window.getSelection();\n-      var selectedText = selection.toString();\n-\n-      if (!selectedText) {\n-        // Selection cleared\n-        isSelecting = false;\n-        lastCfiRange = null;\n-        if (selectionTimeout) {\n-          clearTimeout(selectionTimeout);\n-          selectionTimeout = null;\n-        }\n-        window.flutter_inappwebview.callHandler('selectionCleared');\n-      } else if (isSelecting) {\n-        // Selection is being modified (dragging handles)\n-        // Notify Flutter to hide the widget\n-        window.flutter_inappwebview.callHandler('selectionChanging');\n-\n-        // Clear existing timeout\n-        if (selectionTimeout) {\n-          clearTimeout(selectionTimeout);\n-        }\n-\n-        // Set timeout to detect when dragging stops\n-        selectionTimeout = setTimeout(function () {\n-          // Selection has stabilized, send the final selection\n-          if (lastCfiRange) {\n-            sendSelectionData(lastCfiRange, contents);\n-          }\n-          isSelecting = false;\n-        }, 300); // 300ms debounce\n-      }\n-    });\n-  });\n-\n-  book.loaded.navigation.then(function (toc) {\n-    chapters = parseChapters(toc)\n-    window.flutter_inappwebview.callHandler('chapters');\n-  })\n-\n-  rendition.on(\"rendered\", function () {\n-    window.flutter_inappwebview.callHandler('rendered');\n-  })\n-\n-  // Function to calculate and send selection data\n-  function sendSelectionData(cfiRange, contents) {\n-    book.getRange(cfiRange).then(function (range) {\n-      var selectedText = range.toString();\n-\n-      try {\n-        // Get selection coordinates\n-        var selection = contents.window.getSelection();\n-        var rect = null;\n-\n-        if (selection && selection.rangeCount > 0) {\n-          // Get the range and its client rect (relative to iframe viewport)\n-          var selRange = selection.getRangeAt(0);\n-          var clientRect = selRange.getBoundingClientRect();\n-\n-          // Get the WebView dimensions (parent window)\n-          var webViewWidth = window.innerWidth;\n-          var webViewHeight = window.innerHeight;\n-\n-          // Get the iframe element in the parent document\n-          var iframe = contents.document.defaultView.frameElement;\n-          var iframeRect = iframe.getBoundingClientRect();\n-\n-          // Calculate absolute position in WebView (iframe offset + selection position)\n-          var absoluteLeft = iframeRect.left + clientRect.left;\n-          var absoluteTop = iframeRect.top + clientRect.top;\n-\n-          // Normalize to 0-1 range relative to WebView dimensions\n-          rect = {\n-            left: absoluteLeft / webViewWidth,\n-            top: absoluteTop / webViewHeight,\n-            width: clientRect.width / webViewWidth,\n-            height: clientRect.height / webViewHeight,\n-            contentHeight: webViewHeight\n-          };\n-        }\n-\n-        var args = [cfiRange.toString(), selectedText, rect];\n-        window.flutter_inappwebview.callHandler('selection', ...args);\n-      } catch (e) {\n-        // Still send the selection without coordinates if there's an error\n-        var args = [cfiRange.toString(), selectedText, null];\n-        window.flutter_inappwebview.callHandler('selection', ...args);\n-      }\n-    });\n-  }\n-\n-  ///text selection callback\n-  rendition.on(\"selected\", function (cfiRange, contents) {\n-    lastCfiRange = cfiRange;\n-\n-    if (!isSelecting) {\n-      // Initial selection - send immediately\n-      isSelecting = true;\n-      sendSelectionData(cfiRange, contents);\n-    }\n-    // If already selecting, the selectionchange handler will debounce it\n-  });\n-\n-  //book location changes callback\n-  rendition.on(\"relocated\", function (location) {\n-    // Clear selection when navigating to a new page (if enabled)\n-    if (clearSelectionOnPageChange && (isSelecting || lastCfiRange)) {\n-      isSelecting = false;\n-      lastCfiRange = null;\n-      if (selectionTimeout) {\n-        clearTimeout(selectionTimeout);\n-        selectionTimeout = null;\n-      }\n-\n-      // Clear the actual browser selection across all iframe contents\n-      rendition.getContents().forEach(function (contents) {\n-        try {\n-          if (contents.window.getSelection) {\n-            contents.window.getSelection().removeAllRanges();\n-          }\n-        } catch (e) {\n-          // Ignore errors if iframe is not accessible\n-        }\n-      });\n-\n-      // Notify Flutter that selection was cleared\n-      window.flutter_inappwebview.callHandler('selectionCleared');\n-    }\n-\n-    var percent = location.start.percentage;\n-    var location = {\n-      startCfi: location.start.cfi,\n-      endCfi: location.end.cfi,\n-      progress: percent\n-    }\n-    var args = [location]\n-    window.flutter_inappwebview.callHandler('relocated', ...args);\n-  });\n-\n-  rendition.on('displayError', function (e) {\n-    window.flutter_inappwebview.callHandler('displayError');\n-  })\n-\n-  rendition.on('markClicked', function (cfiRange) {\n-    var args = [cfiRange.toString()]\n-    window.flutter_inappwebview.callHandler('markClicked', ...args);\n-  })\n-\n-  book.ready.then(function () {\n-    book.locations.generate(1600).then(() => {\n-      if (cfi) {\n-        rendition.display(cfi)\n-      }\n-      window.flutter_inappwebview.callHandler('locationLoaded');\n-    })\n-  })\n-\n-  rendition.hooks.content.register((contents) => {\n-\n-    if (useCustomSwipe) {\n-      const el = contents.document.documentElement;\n-\n-      if (el) {\n-        // console.log('EPUB_TEST_HOOK_IF')\n-        detectSwipe(el, function (el, direction) {\n-          // console.log(\"EPUB_TEST_DIR\"+direction.toString())\n-\n-          if (direction == 'l') {\n-            rendition.next()\n-          }\n-          if (direction == 'r') {\n-            rendition.prev()\n-          }\n-        });\n-      }\n-    }\n-  });\n-  rendition.themes.fontSize(fontSize + \"px\");\n-  //set background and foreground color\n-  updateTheme(backgroundColor, foregroundColor);\n-}\n-\n-window.addEventListener(\"flutterInAppWebViewPlatformReady\", function (event) {\n-  window.flutter_inappwebview.callHandler('readyToLoad');\n-});\n-\n-//move to next page\n-function next() {\n-  rendition.next()\n-}\n-\n-//move to previous page\n-function previous() {\n-  rendition.prev()\n-}\n-\n-//move to given cfi location\n-function toCfi(cfi) {\n-  rendition.display(cfi)\n-}\n-\n-//get all chapters\n-function getChapters() {\n-  return chapters;\n-}\n-\n-async function getBookInfo() {\n-  const metadata = book.package.metadata;\n-  metadata['coverImage'] = book.cover;\n-  console.log(\"getBookInfo\", await book.coverUrl());\n-  return metadata;\n-}\n-\n-function getCurrentLocation() {\n-  var percent = rendition.location.start.percentage;\n-  // var percentage = Math.floor(percent * 100);\n-  var location = {\n-    startCfi: rendition.location.start.cfi,\n-    endCfi: rendition.location.end.cfi,\n-    progress: percent\n-  }\n-  return location;\n-}\n-\n-///parsing chapters and subitems recursively\n-var parseChapters = function (toc) {\n-  var chapters = []\n-  toc.forEach(function (chapter) {\n-    chapters.push({\n-      title: chapter.label,\n-      href: chapter.href,\n-      id: chapter.id,\n-      subitems: parseChapters(chapter.subitems)\n-    })\n-  })\n-  return chapters;\n-}\n-\n-function searchInBook(query) {\n-  search(query).then(function (data) {\n-    var args = [data]\n-    window.flutter_inappwebview.callHandler('search', ...args);\n-  })\n-}\n-\n-\n-// adds highlight with given color\n-function addHighlight(cfiRange, color, opacity) {\n-  rendition.annotations.highlight(cfiRange, {}, (e) => {\n-    // console.log(\"highlight clicked\", e.target);\n-  }, \"hl\", { \"fill\": color, \"fill-opacity\": '0.3', \"mix-blend-mode\": \"multiply\" });\n-}\n-\n-// adds underline with optional color and style (solid/dashed)\n-function addUnderLine(cfiString, color, isDashed) {\n-  var underlineColor = color || \"black\";\n-\n-  // Create the underline annotation\n-  var annotation = rendition.annotations.underline(cfiString, {}, (e) => {\n-    // console.log(\"underline clicked\", e.target);\n-  }, \"ul\");\n-\n-  // Customize the line style after creation\n-  if (annotation && annotation.mark && annotation.mark.element) {\n-    // Remove all rect elements (we only want the line, not the box)\n-    var rects = annotation.mark.element.querySelectorAll('rect');\n-    rects.forEach(function (rect) {\n-      rect.remove();\n-    });\n-\n-    // Customize the line elements\n-    var lines = annotation.mark.element.querySelectorAll('line');\n-    lines.forEach(function (line) {\n-      line.setAttribute('stroke', underlineColor);\n-      line.setAttribute('stroke-opacity', '1'); // Fully opaque, no transparency\n-      if (isDashed) {\n-        line.setAttribute('stroke-dasharray', '5,3'); // 5px dash, 3px gap\n-      }\n-    });\n-  }\n-\n-  return annotation;\n-}\n-\n-function addMark(cfiString) {\n-  rendition.annotations.mark(cfiString)\n-}\n-\n-function removeHighlight(cfiString) {\n-  rendition.annotations.remove(cfiString, \"highlight\");\n-}\n-\n-function removeUnderLine(cfiString) {\n-  rendition.annotations.remove(cfiString, \"underline\");\n-}\n-\n-function removeMark(cfiString) {\n-  rendition.annotations.remove(cfiString, \"mark\");\n-}\n-\n-function toProgress(progress) {\n-  var cfi = book.locations.cfiFromPercentage(progress);\n-  rendition.display(cfi);\n-}\n-\n-\n-function search(q) {\n-  return Promise.all(\n-    book.spine.spineItems.map(item => item.load(book.load.bind(book)).then(item.find.bind(item, q)).finally(item.unload.bind(item)))\n-  ).then(results => Promise.resolve([].concat.apply([], results)));\n-};\n-\n-function setFontSize(fontSize) {\n-  rendition.themes.default({\n-    p: {\n-      // \"margin\": '10px',\n-      \"font-size\": `${fontSize}px`\n-    }\n-  });\n-}\n-\n-function setSpread(spread) {\n-  rendition.spread(spread);\n-}\n-\n-function setFlow(flow) {\n-  rendition.flow(flow);\n-}\n-\n-function setManager(manager) {\n-  rendition.manager(manager);\n-}\n-\n-function setFontSize(fontSize) {\n-  rendition.themes.fontSize(`${fontSize}px`);\n-  rendition.reportLocation();\n-}\n-\n-//get current page text\n-function getCurrentPageText() {\n-  var startCfi = rendition.location.start.cfi\n-  var endCfi = rendition.location.end.cfi\n-  var cfiRange = makeRangeCfi(startCfi, endCfi)\n-  book.getRange(cfiRange).then(function (range) {\n-    var text = range.toString();\n-    var args = [text, cfiRange]\n-    window.flutter_inappwebview.callHandler('epubText', ...args);\n-  })\n-}\n-\n-//get text from a range\n-function getTextFromCfi(startCfi, endCfi) {\n-  var cfiRange = makeRangeCfi(startCfi, endCfi)\n-  book.getRange(cfiRange).then(function (range) {\n-    var text = range.toString();\n-    var args = [text, cfiRange]\n-    window.flutter_inappwebview.callHandler('epubText', ...args);\n-  })\n-}\n-\n-///update theme\n-function updateTheme(backgroundColor, foregroundColor) {\n-  if (backgroundColor && foregroundColor) {\n-    rendition.themes.register(\"dark\", { \"body\": { \"background\": backgroundColor, \"color\": foregroundColor } });\n-    rendition.themes.select(\"dark\");\n-  }\n-}\n-\n-const makeRangeCfi = (a, b) => {\n-  const CFI = new ePub.CFI()\n-  const start = CFI.parse(a), end = CFI.parse(b)\n-  const cfi = {\n-    range: true,\n-    base: start.base,\n-    path: {\n-      steps: [],\n-      terminal: null\n-    },\n-    start: start.path,\n-    end: end.path\n-  }\n-  const len = cfi.start.steps.length\n-  for (let i = 0; i < len; i++) {\n-    if (CFI.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n-      if (i == len - 1) {\n-        // Last step is equal, check terminals\n-        if (cfi.start.terminal === cfi.end.terminal) {\n-          // CFI's are equal\n-          cfi.path.steps.push(cfi.start.steps[i])\n-          // Not a range\n-          cfi.range = false\n-        }\n-      } else cfi.path.steps.push(cfi.start.steps[i])\n-    } else break\n-  }\n-  cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length)\n-  cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length)\n-\n-  return 'epubcfi(' + CFI.segmentString(cfi.base)\n-    + '!' + CFI.segmentString(cfi.path)\n-    + ',' + CFI.segmentString(cfi.start)\n-    + ',' + CFI.segmentString(cfi.end)\n-    + ')'\n-}\n-\n-function detectSwipe(el, func) {\n-  swipe_det = new Object();\n-  swipe_det.sX = 0;\n-  swipe_det.sY = 0;\n-  swipe_det.eX = 0;\n-  swipe_det.eY = 0;\n-  var min_x = 50;  //min x swipe for horizontal swipe\n-  var max_x = 40;  //max x difference for vertical swipe\n-  var min_y = 40;  //min y swipe for vertical swipe\n-  var max_y = 50;  //max y difference for horizontal swipe\n-  var direc = \"\";\n-  ele = el\n-  ele.addEventListener('touchstart', function (e) {\n-    var t = e.touches[0];\n-    swipe_det.sX = t.screenX;\n-    swipe_det.sY = t.screenY;\n-  }, false);\n-  ele.addEventListener('touchmove', function (e) {\n-    e.preventDefault();\n-    var t = e.touches[0];\n-    swipe_det.eX = t.screenX;\n-    swipe_det.eY = t.screenY;\n-  }, false);\n-  ele.addEventListener('touchend', function (e) {\n-    //horizontal detection\n-    if ((((swipe_det.eX - min_x > swipe_det.sX) || (swipe_det.eX + min_x < swipe_det.sX)) && ((swipe_det.eY < swipe_det.sY + max_y) && (swipe_det.sY > swipe_det.eY - max_y)))) {\n-      if (swipe_det.eX > swipe_det.sX) direc = \"r\";\n-      else direc = \"l\";\n-    }\n-    //vertical detection\n-    if ((((swipe_det.eY - min_y > swipe_det.sY) || (swipe_det.eY + min_y < swipe_det.sY)) && ((swipe_det.eX < swipe_det.sX + max_x) && (swipe_det.sX > swipe_det.eX - max_x)))) {\n-      if (swipe_det.eY > swipe_det.sY) direc = \"d\";\n-      else direc = \"u\";\n-    }\n-\n-    if (direc != \"\") {\n-      if (typeof func == 'function') func(el, direc);\n-    }\n-    direc = \"\";\n-  }, false);\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1762659078856,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -322,10 +322,10 @@\n         line.style.setProperty('stroke', underlineColor, 'important');\n         line.style.setProperty('stroke-opacity', '1', 'important');\n         line.style.setProperty('opacity', '1', 'important');\n         if (isDashed) {\n-          line.setAttribute('stroke-dasharray', '5,3');\n-          line.style.setProperty('stroke-dasharray', '5,3', 'important');\n+          line.setAttribute('stroke-dasharray', '2,2');\n+          line.style.setProperty('stroke-dasharray', '2,2', 'important');\n         }\n       });\n     }\n   }, 10);\n"
                },
                {
                    "date": 1762663426502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,9 @@\n var rendition;\n var displayed;\n var chapters = []\n var clearSelectionOnPageChange = true; // Global flag for selection clearing behavior\n+var underlineStyles = {}; // Store underline styles by CFI for re-rendering\n \n \n \n function loadBook(data, cfi, manager, flow, spread, snap, allowScriptedContent, direction, useCustomSwipe, backgroundColor, foregroundColor, fontSize, clearSelectionOnNav) {\n@@ -81,9 +82,9 @@\n     chapters = parseChapters(toc)\n     window.flutter_inappwebview.callHandler('chapters');\n   })\n \n-  rendition.on(\"rendered\", function () {\n+  rendition.on(\"rendered\", function (section) {\n     window.flutter_inappwebview.callHandler('rendered');\n   })\n \n   // Function to calculate and send selection data\n@@ -199,8 +200,45 @@\n     })\n   })\n \n   rendition.hooks.content.register((contents) => {\n+    // Set up MutationObserver to watch for underline elements\n+    var doc = contents.document;\n+    \n+    // Immediately apply styles to existing underlines\n+    setTimeout(function() {\n+      var underlines = doc.querySelectorAll('.epubjs-ul');\n+      underlines.forEach(function(el) {\n+        fixUnderlineElement(el);\n+      });\n+    }, 20);\n+    \n+    // Watch for new underline elements being added\n+    var observer = new MutationObserver(function(mutations) {\n+      mutations.forEach(function(mutation) {\n+        mutation.addedNodes.forEach(function(node) {\n+          if (node.nodeType === 1) { // Element node\n+            // Check if it's an underline or contains underlines\n+            if (node.classList && node.classList.contains('epubjs-ul')) {\n+              setTimeout(function() { fixUnderlineElement(node); }, 10);\n+            }\n+            // Also check children\n+            if (node.querySelectorAll) {\n+              var underlines = node.querySelectorAll('.epubjs-ul');\n+              underlines.forEach(function(el) {\n+                setTimeout(function() { fixUnderlineElement(el); }, 10);\n+              });\n+            }\n+          }\n+        });\n+      });\n+    });\n+    \n+    // Start observing\n+    observer.observe(doc.body, {\n+      childList: true,\n+      subtree: true\n+    });\n \n     if (useCustomSwipe) {\n       const el = contents.document.documentElement;\n \n@@ -294,40 +332,75 @@\n     // console.log(\"highlight clicked\", e.target);\n   }, \"hl\", { \"fill\": color, \"fill-opacity\": '0.3', \"mix-blend-mode\": \"multiply\" });\n }\n \n+// Function to apply underline styles to an element\n+function applyUnderlineStyles(element, color, isDashed) {\n+  if (!element) return;\n+  \n+  // Remove all rect elements (we only want the line, not the box)\n+  var rects = element.querySelectorAll('rect');\n+  rects.forEach(function (rect) {\n+    rect.remove();\n+  });\n+\n+  // Customize the line elements with !important styles\n+  var lines = element.querySelectorAll('line');\n+  lines.forEach(function (line) {\n+    line.setAttribute('stroke', color);\n+    line.setAttribute('stroke-opacity', '1');\n+    line.setAttribute('opacity', '1');\n+    line.style.setProperty('stroke', color, 'important');\n+    line.style.setProperty('stroke-opacity', '1', 'important');\n+    line.style.setProperty('opacity', '1', 'important');\n+    if (isDashed) {\n+      line.setAttribute('stroke-dasharray', '2,2');\n+      line.style.setProperty('stroke-dasharray', '2,2', 'important');\n+    }\n+  });\n+}\n+\n+// Fix a single underline element by checking stored styles\n+function fixUnderlineElement(element) {\n+  if (!element) return;\n+  \n+  // Try to find matching style from stored styles\n+  // Check all stored CFIs and apply the first match\n+  var applied = false;\n+  for (var cfi in underlineStyles) {\n+    var style = underlineStyles[cfi];\n+    // Apply the style (we'll apply to all underlines since we can't reliably match CFI)\n+    applyUnderlineStyles(element, style.color, style.isDashed);\n+    applied = true;\n+    break; // For now, assume all notes use same style\n+  }\n+  \n+  // If we have any stored styles, apply red dashed as default\n+  if (!applied && Object.keys(underlineStyles).length > 0) {\n+    applyUnderlineStyles(element, '#ff0000', true);\n+  }\n+}\n+\n // adds underline with optional color and style (solid/dashed)\n function addUnderLine(cfiString, color, isDashed) {\n   var underlineColor = color || \"black\";\n+  \n+  // Store the style for re-rendering\n+  underlineStyles[cfiString] = {\n+    color: underlineColor,\n+    isDashed: isDashed || false\n+  };\n \n-  // Create the underline annotation\n+  // Create the underline annotation with click handler\n   var annotation = rendition.annotations.underline(cfiString, {}, (e) => {\n-    // console.log(\"underline clicked\", e.target);\n+    // Notify Flutter when underline is clicked\n+    window.flutter_inappwebview.callHandler('markClicked', cfiString);\n   }, \"ul\");\n \n   // Use setTimeout to ensure DOM elements are fully created\n   setTimeout(function () {\n     if (annotation && annotation.mark && annotation.mark.element) {\n-      // Remove all rect elements (we only want the line, not the box)\n-      var rects = annotation.mark.element.querySelectorAll('rect');\n-      rects.forEach(function (rect) {\n-        rect.remove();\n-      });\n-\n-      // Customize the line elements with !important styles\n-      var lines = annotation.mark.element.querySelectorAll('line');\n-      lines.forEach(function (line) {\n-        line.setAttribute('stroke', underlineColor);\n-        line.setAttribute('stroke-opacity', '1');\n-        line.setAttribute('opacity', '1');\n-        line.style.setProperty('stroke', underlineColor, 'important');\n-        line.style.setProperty('stroke-opacity', '1', 'important');\n-        line.style.setProperty('opacity', '1', 'important');\n-        if (isDashed) {\n-          line.setAttribute('stroke-dasharray', '2,2');\n-          line.style.setProperty('stroke-dasharray', '2,2', 'important');\n-        }\n-      });\n+      applyUnderlineStyles(annotation.mark.element, underlineColor, isDashed);\n     }\n   }, 10);\n \n   return annotation;\n@@ -342,8 +415,10 @@\n }\n \n function removeUnderLine(cfiString) {\n   rendition.annotations.remove(cfiString, \"underline\");\n+  // Remove from stored styles\n+  delete underlineStyles[cfiString];\n }\n \n function removeMark(cfiString) {\n   rendition.annotations.remove(cfiString, \"mark\");\n"
                },
                {
                    "date": 1762663432102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -202,38 +202,38 @@\n \n   rendition.hooks.content.register((contents) => {\n     // Set up MutationObserver to watch for underline elements\n     var doc = contents.document;\n-    \n+\n     // Immediately apply styles to existing underlines\n-    setTimeout(function() {\n+    setTimeout(function () {\n       var underlines = doc.querySelectorAll('.epubjs-ul');\n-      underlines.forEach(function(el) {\n+      underlines.forEach(function (el) {\n         fixUnderlineElement(el);\n       });\n     }, 20);\n-    \n+\n     // Watch for new underline elements being added\n-    var observer = new MutationObserver(function(mutations) {\n-      mutations.forEach(function(mutation) {\n-        mutation.addedNodes.forEach(function(node) {\n+    var observer = new MutationObserver(function (mutations) {\n+      mutations.forEach(function (mutation) {\n+        mutation.addedNodes.forEach(function (node) {\n           if (node.nodeType === 1) { // Element node\n             // Check if it's an underline or contains underlines\n             if (node.classList && node.classList.contains('epubjs-ul')) {\n-              setTimeout(function() { fixUnderlineElement(node); }, 10);\n+              setTimeout(function () { fixUnderlineElement(node); }, 10);\n             }\n             // Also check children\n             if (node.querySelectorAll) {\n               var underlines = node.querySelectorAll('.epubjs-ul');\n-              underlines.forEach(function(el) {\n-                setTimeout(function() { fixUnderlineElement(el); }, 10);\n+              underlines.forEach(function (el) {\n+                setTimeout(function () { fixUnderlineElement(el); }, 10);\n               });\n             }\n           }\n         });\n       });\n     });\n-    \n+\n     // Start observing\n     observer.observe(doc.body, {\n       childList: true,\n       subtree: true\n@@ -335,9 +335,9 @@\n \n // Function to apply underline styles to an element\n function applyUnderlineStyles(element, color, isDashed) {\n   if (!element) return;\n-  \n+\n   // Remove all rect elements (we only want the line, not the box)\n   var rects = element.querySelectorAll('rect');\n   rects.forEach(function (rect) {\n     rect.remove();\n@@ -361,9 +361,9 @@\n \n // Fix a single underline element by checking stored styles\n function fixUnderlineElement(element) {\n   if (!element) return;\n-  \n+\n   // Try to find matching style from stored styles\n   // Check all stored CFIs and apply the first match\n   var applied = false;\n   for (var cfi in underlineStyles) {\n@@ -372,9 +372,9 @@\n     applyUnderlineStyles(element, style.color, style.isDashed);\n     applied = true;\n     break; // For now, assume all notes use same style\n   }\n-  \n+\n   // If we have any stored styles, apply red dashed as default\n   if (!applied && Object.keys(underlineStyles).length > 0) {\n     applyUnderlineStyles(element, '#ff0000', true);\n   }\n@@ -382,9 +382,9 @@\n \n // adds underline with optional color and style (solid/dashed)\n function addUnderLine(cfiString, color, isDashed) {\n   var underlineColor = color || \"black\";\n-  \n+\n   // Store the style for re-rendering\n   underlineStyles[cfiString] = {\n     color: underlineColor,\n     isDashed: isDashed || false\n"
                },
                {
                    "date": 1762663795553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -200,44 +200,62 @@\n     })\n   })\n \n   rendition.hooks.content.register((contents) => {\n-    // Set up MutationObserver to watch for underline elements\n+    // Set up handler to fix underline elements\n     var doc = contents.document;\n \n-    // Immediately apply styles to existing underlines\n-    setTimeout(function () {\n+    // Function to scan and fix all underlines in the document\n+    function scanAndFixUnderlines() {\n       var underlines = doc.querySelectorAll('.epubjs-ul');\n-      underlines.forEach(function (el) {\n-        fixUnderlineElement(el);\n-      });\n-    }, 20);\n+      if (underlines.length > 0) {\n+        console.log('Found ' + underlines.length + ' underline(s), fixing styles...');\n+        underlines.forEach(function (el) {\n+          fixUnderlineElement(el);\n+        });\n+      }\n+    }\n \n+    // Apply styles multiple times with different delays to catch all rendering scenarios\n+    setTimeout(scanAndFixUnderlines, 10);\n+    setTimeout(scanAndFixUnderlines, 50);\n+    setTimeout(scanAndFixUnderlines, 100);\n+    setTimeout(scanAndFixUnderlines, 200);\n+\n     // Watch for new underline elements being added\n     var observer = new MutationObserver(function (mutations) {\n+      var needsFix = false;\n       mutations.forEach(function (mutation) {\n         mutation.addedNodes.forEach(function (node) {\n           if (node.nodeType === 1) { // Element node\n             // Check if it's an underline or contains underlines\n             if (node.classList && node.classList.contains('epubjs-ul')) {\n-              setTimeout(function () { fixUnderlineElement(node); }, 10);\n+              needsFix = true;\n             }\n             // Also check children\n             if (node.querySelectorAll) {\n               var underlines = node.querySelectorAll('.epubjs-ul');\n-              underlines.forEach(function (el) {\n-                setTimeout(function () { fixUnderlineElement(el); }, 10);\n-              });\n+              if (underlines.length > 0) {\n+                needsFix = true;\n+              }\n             }\n           }\n         });\n       });\n+\n+      // Batch fix all underlines if any were found\n+      if (needsFix) {\n+        setTimeout(scanAndFixUnderlines, 10);\n+        setTimeout(scanAndFixUnderlines, 50);\n+      }\n     });\n \n     // Start observing\n     observer.observe(doc.body, {\n       childList: true,\n-      subtree: true\n+      subtree: true,\n+      attributes: true,\n+      attributeFilter: ['class']\n     });\n \n     if (useCustomSwipe) {\n       const el = contents.document.documentElement;\n@@ -358,27 +376,15 @@\n     }\n   });\n }\n \n-// Fix a single underline element by checking stored styles\n+// Fix a single underline element - always apply red dashed style for notes\n function fixUnderlineElement(element) {\n   if (!element) return;\n-\n-  // Try to find matching style from stored styles\n-  // Check all stored CFIs and apply the first match\n-  var applied = false;\n-  for (var cfi in underlineStyles) {\n-    var style = underlineStyles[cfi];\n-    // Apply the style (we'll apply to all underlines since we can't reliably match CFI)\n-    applyUnderlineStyles(element, style.color, style.isDashed);\n-    applied = true;\n-    break; // For now, assume all notes use same style\n-  }\n-\n-  // If we have any stored styles, apply red dashed as default\n-  if (!applied && Object.keys(underlineStyles).length > 0) {\n-    applyUnderlineStyles(element, '#ff0000', true);\n-  }\n+  \n+  // Always apply red dashed underline style\n+  // This ensures consistency even when underlineStyles might be empty\n+  applyUnderlineStyles(element, '#ff0000', true);\n }\n \n // adds underline with optional color and style (solid/dashed)\n function addUnderLine(cfiString, color, isDashed) {\n"
                },
                {
                    "date": 1762663809126,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -379,9 +379,9 @@\n \n // Fix a single underline element - always apply red dashed style for notes\n function fixUnderlineElement(element) {\n   if (!element) return;\n-  \n+\n   // Always apply red dashed underline style\n   // This ensures consistency even when underlineStyles might be empty\n   applyUnderlineStyles(element, '#ff0000', true);\n }\n"
                },
                {
                    "date": 1762664031508,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -205,22 +205,40 @@\n     var doc = contents.document;\n \n     // Function to scan and fix all underlines in the document\n     function scanAndFixUnderlines() {\n-      var underlines = doc.querySelectorAll('.epubjs-ul');\n+      console.log('[EPUB] Scanning for underlines...');\n+      \n+      // Try multiple selectors\n+      var underlines = doc.querySelectorAll('.epubjs-ul, [class*=\"epubjs-ul\"], svg.epubjs-ul');\n+      console.log('[EPUB] Found ' + underlines.length + ' underline element(s)');\n+      \n       if (underlines.length > 0) {\n-        console.log('Found ' + underlines.length + ' underline(s), fixing styles...');\n-        underlines.forEach(function (el) {\n+        underlines.forEach(function (el, index) {\n+          console.log('[EPUB] Fixing underline #' + (index + 1));\n           fixUnderlineElement(el);\n         });\n       }\n+      \n+      // Also try to find SVG elements that might be annotations\n+      var allSvgs = doc.querySelectorAll('svg');\n+      console.log('[EPUB] Total SVG elements: ' + allSvgs.length);\n+      allSvgs.forEach(function(svg) {\n+        if (svg.className && svg.className.baseVal && svg.className.baseVal.indexOf('ul') >= 0) {\n+          console.log('[EPUB] Found SVG with ul class, fixing...');\n+          fixUnderlineElement(svg);\n+        }\n+      });\n     }\n \n     // Apply styles multiple times with different delays to catch all rendering scenarios\n+    console.log('[EPUB] Content registered, starting scans...');\n     setTimeout(scanAndFixUnderlines, 10);\n     setTimeout(scanAndFixUnderlines, 50);\n     setTimeout(scanAndFixUnderlines, 100);\n     setTimeout(scanAndFixUnderlines, 200);\n+    setTimeout(scanAndFixUnderlines, 500);\n+    setTimeout(scanAndFixUnderlines, 1000);\n \n     // Watch for new underline elements being added\n     var observer = new MutationObserver(function (mutations) {\n       var needsFix = false;\n@@ -228,14 +246,21 @@\n         mutation.addedNodes.forEach(function (node) {\n           if (node.nodeType === 1) { // Element node\n             // Check if it's an underline or contains underlines\n             if (node.classList && node.classList.contains('epubjs-ul')) {\n+              console.log('[EPUB] MutationObserver detected new underline');\n               needsFix = true;\n             }\n+            // Also check for SVG\n+            if (node.tagName && node.tagName.toLowerCase() === 'svg') {\n+              console.log('[EPUB] MutationObserver detected new SVG');\n+              needsFix = true;\n+            }\n             // Also check children\n             if (node.querySelectorAll) {\n-              var underlines = node.querySelectorAll('.epubjs-ul');\n+              var underlines = node.querySelectorAll('.epubjs-ul, svg');\n               if (underlines.length > 0) {\n+                console.log('[EPUB] MutationObserver detected ' + underlines.length + ' new child elements');\n                 needsFix = true;\n               }\n             }\n           }\n@@ -243,8 +268,9 @@\n       });\n \n       // Batch fix all underlines if any were found\n       if (needsFix) {\n+        console.log('[EPUB] MutationObserver triggering fix...');\n         setTimeout(scanAndFixUnderlines, 10);\n         setTimeout(scanAndFixUnderlines, 50);\n       }\n     });\n@@ -253,9 +279,9 @@\n     observer.observe(doc.body, {\n       childList: true,\n       subtree: true,\n       attributes: true,\n-      attributeFilter: ['class']\n+      attributeFilter: ['class', 'style']\n     });\n \n     if (useCustomSwipe) {\n       const el = contents.document.documentElement;\n"
                },
                {
                    "date": 1762667616476,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -206,24 +206,24 @@\n \n     // Function to scan and fix all underlines in the document\n     function scanAndFixUnderlines() {\n       console.log('[EPUB] Scanning for underlines...');\n-      \n+\n       // Try multiple selectors\n       var underlines = doc.querySelectorAll('.epubjs-ul, [class*=\"epubjs-ul\"], svg.epubjs-ul');\n       console.log('[EPUB] Found ' + underlines.length + ' underline element(s)');\n-      \n+\n       if (underlines.length > 0) {\n         underlines.forEach(function (el, index) {\n           console.log('[EPUB] Fixing underline #' + (index + 1));\n           fixUnderlineElement(el);\n         });\n       }\n-      \n+\n       // Also try to find SVG elements that might be annotations\n       var allSvgs = doc.querySelectorAll('svg');\n       console.log('[EPUB] Total SVG elements: ' + allSvgs.length);\n-      allSvgs.forEach(function(svg) {\n+      allSvgs.forEach(function (svg) {\n         if (svg.className && svg.className.baseVal && svg.className.baseVal.indexOf('ul') >= 0) {\n           console.log('[EPUB] Found SVG with ul class, fixing...');\n           fixUnderlineElement(svg);\n         }\n"
                },
                {
                    "date": 1762667747637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -414,27 +414,44 @@\n \n // adds underline with optional color and style (solid/dashed)\n function addUnderLine(cfiString, color, isDashed) {\n   var underlineColor = color || \"black\";\n-\n+  \n   // Store the style for re-rendering\n   underlineStyles[cfiString] = {\n     color: underlineColor,\n     isDashed: isDashed || false\n   };\n \n+  console.log('[EPUB] addUnderLine called for CFI: ' + cfiString.substring(0, 30) + '...');\n+\n   // Create the underline annotation with click handler\n   var annotation = rendition.annotations.underline(cfiString, {}, (e) => {\n     // Notify Flutter when underline is clicked\n     window.flutter_inappwebview.callHandler('markClicked', cfiString);\n   }, \"ul\");\n \n-  // Use setTimeout to ensure DOM elements are fully created\n-  setTimeout(function () {\n+  // Fix styles immediately and with delays\n+  var fixAttempts = 0;\n+  var maxAttempts = 10;\n+  \n+  function tryFix() {\n+    fixAttempts++;\n     if (annotation && annotation.mark && annotation.mark.element) {\n+      console.log('[EPUB] Fixing underline annotation (attempt ' + fixAttempts + ')');\n       applyUnderlineStyles(annotation.mark.element, underlineColor, isDashed);\n+      return true;\n+    } else if (fixAttempts < maxAttempts) {\n+      setTimeout(tryFix, 50 * fixAttempts);\n+      return false;\n+    } else {\n+      console.log('[EPUB] Failed to fix underline after ' + maxAttempts + ' attempts');\n+      return false;\n     }\n-  }, 10);\n+  }\n+  \n+  // Start trying to fix\n+  setTimeout(tryFix, 10);\n \n   return annotation;\n }\n \n"
                },
                {
                    "date": 1762667763324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -414,9 +414,9 @@\n \n // adds underline with optional color and style (solid/dashed)\n function addUnderLine(cfiString, color, isDashed) {\n   var underlineColor = color || \"black\";\n-  \n+\n   // Store the style for re-rendering\n   underlineStyles[cfiString] = {\n     color: underlineColor,\n     isDashed: isDashed || false\n@@ -432,9 +432,9 @@\n \n   // Fix styles immediately and with delays\n   var fixAttempts = 0;\n   var maxAttempts = 10;\n-  \n+\n   function tryFix() {\n     fixAttempts++;\n     if (annotation && annotation.mark && annotation.mark.element) {\n       console.log('[EPUB] Fixing underline annotation (attempt ' + fixAttempts + ')');\n@@ -447,9 +447,9 @@\n       console.log('[EPUB] Failed to fix underline after ' + maxAttempts + ' attempts');\n       return false;\n     }\n   }\n-  \n+\n   // Start trying to fix\n   setTimeout(tryFix, 10);\n \n   return annotation;\n"
                },
                {
                    "date": 1762668018579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,32 +203,48 @@\n   rendition.hooks.content.register((contents) => {\n     // Set up handler to fix underline elements\n     var doc = contents.document;\n \n-    // Function to scan and fix all underlines in the document\n+    // Function to scan and fix all underlines in the document  \n     function scanAndFixUnderlines() {\n-      console.log('[EPUB] Scanning for underlines...');\n+      console.log('[EPUB] Scanning for underlines in iframe...');\n \n-      // Try multiple selectors\n+      // Scan in iframe content\n       var underlines = doc.querySelectorAll('.epubjs-ul, [class*=\"epubjs-ul\"], svg.epubjs-ul');\n-      console.log('[EPUB] Found ' + underlines.length + ' underline element(s)');\n+      console.log('[EPUB] Found ' + underlines.length + ' underline element(s) in iframe');\n \n       if (underlines.length > 0) {\n         underlines.forEach(function (el, index) {\n-          console.log('[EPUB] Fixing underline #' + (index + 1));\n+          console.log('[EPUB] Fixing underline #' + (index + 1) + ' in iframe');\n           fixUnderlineElement(el);\n         });\n       }\n \n-      // Also try to find SVG elements that might be annotations\n-      var allSvgs = doc.querySelectorAll('svg');\n-      console.log('[EPUB] Total SVG elements: ' + allSvgs.length);\n-      allSvgs.forEach(function (svg) {\n-        if (svg.className && svg.className.baseVal && svg.className.baseVal.indexOf('ul') >= 0) {\n-          console.log('[EPUB] Found SVG with ul class, fixing...');\n-          fixUnderlineElement(svg);\n+      // Also scan in main window (where annotation overlay might be)\n+      try {\n+        var mainDoc = window.document || parent.document;\n+        var mainUnderlines = mainDoc.querySelectorAll('.epubjs-ul, [class*=\"epubjs-ul\"], svg.epubjs-ul');\n+        console.log('[EPUB] Found ' + mainUnderlines.length + ' underline element(s) in main window');\n+\n+        if (mainUnderlines.length > 0) {\n+          mainUnderlines.forEach(function (el, index) {\n+            console.log('[EPUB] Fixing underline #' + (index + 1) + ' in main window');\n+            fixUnderlineElement(el);\n+          });\n         }\n-      });\n+\n+        // Check #viewer container\n+        var viewer = mainDoc.querySelector('#viewer');\n+        if (viewer) {\n+          var viewerUnderlines = viewer.querySelectorAll('.epubjs-ul, svg.epubjs-ul');\n+          console.log('[EPUB] Found ' + viewerUnderlines.length + ' underline element(s) in #viewer');\n+          viewerUnderlines.forEach(function (el) {\n+            fixUnderlineElement(el);\n+          });\n+        }\n+      } catch (e) {\n+        console.log('[EPUB] Error scanning main window: ' + e.message);\n+      }\n     }\n \n     // Apply styles multiple times with different delays to catch all rendering scenarios\n     console.log('[EPUB] Content registered, starting scans...');\n"
                },
                {
                    "date": 1762668229617,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,9 @@\n var displayed;\n var chapters = []\n var clearSelectionOnPageChange = true; // Global flag for selection clearing behavior\n var underlineStyles = {}; // Store underline styles by CFI for re-rendering\n+var underlineFixInterval = null; // Interval to continuously fix underlines\n \n \n \n function loadBook(data, cfi, manager, flow, spread, snap, allowScriptedContent, direction, useCustomSwipe, backgroundColor, foregroundColor, fontSize, clearSelectionOnNav) {\n@@ -319,8 +320,29 @@\n   });\n   rendition.themes.fontSize(fontSize + \"px\");\n   //set background and foreground color\n   updateTheme(backgroundColor, foregroundColor);\n+  \n+  // Start continuous underline fixing interval\n+  if (underlineFixInterval) {\n+    clearInterval(underlineFixInterval);\n+  }\n+  underlineFixInterval = setInterval(function() {\n+    // Continuously scan and fix all underlines\n+    var fixed = 0;\n+    rendition.getContents().forEach(function(contents) {\n+      if (contents && contents.document) {\n+        var underlines = contents.document.querySelectorAll('.epubjs-ul, svg.epubjs-ul');\n+        underlines.forEach(function(el) {\n+          fixUnderlineElement(el);\n+          fixed++;\n+        });\n+      }\n+    });\n+    if (fixed > 0) {\n+      console.log('[EPUB] Auto-fixed ' + fixed + ' underline(s)');\n+    }\n+  }, 500); // Check every 500ms\n }\n \n window.addEventListener(\"flutterInAppWebViewPlatformReady\", function (event) {\n   window.flutter_inappwebview.callHandler('readyToLoad');\n"
                },
                {
                    "date": 1762668513329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,8 @@\n var displayed;\n var chapters = []\n var clearSelectionOnPageChange = true; // Global flag for selection clearing behavior\n var underlineStyles = {}; // Store underline styles by CFI for re-rendering\n-var underlineFixInterval = null; // Interval to continuously fix underlines\n \n \n \n function loadBook(data, cfi, manager, flow, spread, snap, allowScriptedContent, direction, useCustomSwipe, backgroundColor, foregroundColor, fontSize, clearSelectionOnNav) {\n@@ -320,29 +319,8 @@\n   });\n   rendition.themes.fontSize(fontSize + \"px\");\n   //set background and foreground color\n   updateTheme(backgroundColor, foregroundColor);\n-  \n-  // Start continuous underline fixing interval\n-  if (underlineFixInterval) {\n-    clearInterval(underlineFixInterval);\n-  }\n-  underlineFixInterval = setInterval(function() {\n-    // Continuously scan and fix all underlines\n-    var fixed = 0;\n-    rendition.getContents().forEach(function(contents) {\n-      if (contents && contents.document) {\n-        var underlines = contents.document.querySelectorAll('.epubjs-ul, svg.epubjs-ul');\n-        underlines.forEach(function(el) {\n-          fixUnderlineElement(el);\n-          fixed++;\n-        });\n-      }\n-    });\n-    if (fixed > 0) {\n-      console.log('[EPUB] Auto-fixed ' + fixed + ' underline(s)');\n-    }\n-  }, 500); // Check every 500ms\n }\n \n window.addEventListener(\"flutterInAppWebViewPlatformReady\", function (event) {\n   window.flutter_inappwebview.callHandler('readyToLoad');\n@@ -475,8 +453,26 @@\n   function tryFix() {\n     fixAttempts++;\n     if (annotation && annotation.mark && annotation.mark.element) {\n       console.log('[EPUB] Fixing underline annotation (attempt ' + fixAttempts + ')');\n+      \n+      // Debug: Print element info\n+      var el = annotation.mark.element;\n+      console.log('[EPUB] Element tag: ' + el.tagName);\n+      console.log('[EPUB] Element class: ' + el.className);\n+      console.log('[EPUB] Element id: ' + el.id);\n+      console.log('[EPUB] Parent tag: ' + (el.parentElement ? el.parentElement.tagName : 'null'));\n+      console.log('[EPUB] Parent class: ' + (el.parentElement ? el.parentElement.className : 'null'));\n+      \n+      // Try to find the root container\n+      var root = el;\n+      var depth = 0;\n+      while (root.parentElement && depth < 10) {\n+        root = root.parentElement;\n+        depth++;\n+      }\n+      console.log('[EPUB] Root container after ' + depth + ' levels: ' + root.tagName + ' (class: ' + root.className + ')');\n+      \n       applyUnderlineStyles(annotation.mark.element, underlineColor, isDashed);\n       return true;\n     } else if (fixAttempts < maxAttempts) {\n       setTimeout(tryFix, 50 * fixAttempts);\n"
                },
                {
                    "date": 1762668754181,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,9 @@\n var displayed;\n var chapters = []\n var clearSelectionOnPageChange = true; // Global flag for selection clearing behavior\n var underlineStyles = {}; // Store underline styles by CFI for re-rendering\n+var underlineAnnotations = {}; // Store annotation objects by CFI for direct access\n \n \n \n function loadBook(data, cfi, manager, flow, spread, snap, allowScriptedContent, direction, useCustomSwipe, backgroundColor, foregroundColor, fontSize, clearSelectionOnNav) {\n@@ -203,48 +204,31 @@\n   rendition.hooks.content.register((contents) => {\n     // Set up handler to fix underline elements\n     var doc = contents.document;\n \n-    // Function to scan and fix all underlines in the document  \n+    // Function to scan and fix all underlines using stored annotation references\n     function scanAndFixUnderlines() {\n-      console.log('[EPUB] Scanning for underlines in iframe...');\n-\n-      // Scan in iframe content\n-      var underlines = doc.querySelectorAll('.epubjs-ul, [class*=\"epubjs-ul\"], svg.epubjs-ul');\n-      console.log('[EPUB] Found ' + underlines.length + ' underline element(s) in iframe');\n-\n-      if (underlines.length > 0) {\n-        underlines.forEach(function (el, index) {\n-          console.log('[EPUB] Fixing underline #' + (index + 1) + ' in iframe');\n-          fixUnderlineElement(el);\n-        });\n-      }\n-\n-      // Also scan in main window (where annotation overlay might be)\n-      try {\n-        var mainDoc = window.document || parent.document;\n-        var mainUnderlines = mainDoc.querySelectorAll('.epubjs-ul, [class*=\"epubjs-ul\"], svg.epubjs-ul');\n-        console.log('[EPUB] Found ' + mainUnderlines.length + ' underline element(s) in main window');\n-\n-        if (mainUnderlines.length > 0) {\n-          mainUnderlines.forEach(function (el, index) {\n-            console.log('[EPUB] Fixing underline #' + (index + 1) + ' in main window');\n-            fixUnderlineElement(el);\n-          });\n+      console.log('[EPUB] Fixing stored underline annotations...');\n+      \n+      var fixedCount = 0;\n+      var totalCount = 0;\n+      \n+      // Iterate through all stored annotation objects\n+      for (var cfi in underlineAnnotations) {\n+        totalCount++;\n+        var annotation = underlineAnnotations[cfi];\n+        var style = underlineStyles[cfi];\n+        \n+        if (annotation && annotation.mark && annotation.mark.element) {\n+          // Direct access to the element through the annotation object\n+          var color = (style && style.color) || '#ff0000';\n+          var isDashed = (style && style.isDashed) || true;\n+          applyUnderlineStyles(annotation.mark.element, color, isDashed);\n+          fixedCount++;\n         }\n-\n-        // Check #viewer container\n-        var viewer = mainDoc.querySelector('#viewer');\n-        if (viewer) {\n-          var viewerUnderlines = viewer.querySelectorAll('.epubjs-ul, svg.epubjs-ul');\n-          console.log('[EPUB] Found ' + viewerUnderlines.length + ' underline element(s) in #viewer');\n-          viewerUnderlines.forEach(function (el) {\n-            fixUnderlineElement(el);\n-          });\n-        }\n-      } catch (e) {\n-        console.log('[EPUB] Error scanning main window: ' + e.message);\n       }\n+      \n+      console.log('[EPUB] Fixed ' + fixedCount + '/' + totalCount + ' underline annotations');\n     }\n \n     // Apply styles multiple times with different delays to catch all rendering scenarios\n     console.log('[EPUB] Content registered, starting scans...');\n@@ -445,34 +429,19 @@\n     // Notify Flutter when underline is clicked\n     window.flutter_inappwebview.callHandler('markClicked', cfiString);\n   }, \"ul\");\n \n+  // Store the annotation object for direct access later\n+  underlineAnnotations[cfiString] = annotation;\n+\n   // Fix styles immediately and with delays\n   var fixAttempts = 0;\n   var maxAttempts = 10;\n \n   function tryFix() {\n     fixAttempts++;\n     if (annotation && annotation.mark && annotation.mark.element) {\n       console.log('[EPUB] Fixing underline annotation (attempt ' + fixAttempts + ')');\n-      \n-      // Debug: Print element info\n-      var el = annotation.mark.element;\n-      console.log('[EPUB] Element tag: ' + el.tagName);\n-      console.log('[EPUB] Element class: ' + el.className);\n-      console.log('[EPUB] Element id: ' + el.id);\n-      console.log('[EPUB] Parent tag: ' + (el.parentElement ? el.parentElement.tagName : 'null'));\n-      console.log('[EPUB] Parent class: ' + (el.parentElement ? el.parentElement.className : 'null'));\n-      \n-      // Try to find the root container\n-      var root = el;\n-      var depth = 0;\n-      while (root.parentElement && depth < 10) {\n-        root = root.parentElement;\n-        depth++;\n-      }\n-      console.log('[EPUB] Root container after ' + depth + ' levels: ' + root.tagName + ' (class: ' + root.className + ')');\n-      \n       applyUnderlineStyles(annotation.mark.element, underlineColor, isDashed);\n       return true;\n     } else if (fixAttempts < maxAttempts) {\n       setTimeout(tryFix, 50 * fixAttempts);\n@@ -498,10 +467,11 @@\n }\n \n function removeUnderLine(cfiString) {\n   rendition.annotations.remove(cfiString, \"underline\");\n-  // Remove from stored styles\n+  // Remove from stored styles and annotations\n   delete underlineStyles[cfiString];\n+  delete underlineAnnotations[cfiString];\n }\n \n function removeMark(cfiString) {\n   rendition.annotations.remove(cfiString, \"mark\");\n"
                },
                {
                    "date": 1762668771230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -207,27 +207,27 @@\n \n     // Function to scan and fix all underlines using stored annotation references\n     function scanAndFixUnderlines() {\n       console.log('[EPUB] Fixing stored underline annotations...');\n-      \n+\n       var fixedCount = 0;\n       var totalCount = 0;\n-      \n+\n       // Iterate through all stored annotation objects\n       for (var cfi in underlineAnnotations) {\n         totalCount++;\n         var annotation = underlineAnnotations[cfi];\n         var style = underlineStyles[cfi];\n-        \n+\n         if (annotation && annotation.mark && annotation.mark.element) {\n           // Direct access to the element through the annotation object\n           var color = (style && style.color) || '#ff0000';\n           var isDashed = (style && style.isDashed) || true;\n           applyUnderlineStyles(annotation.mark.element, color, isDashed);\n           fixedCount++;\n         }\n       }\n-      \n+\n       console.log('[EPUB] Fixed ' + fixedCount + '/' + totalCount + ' underline annotations');\n     }\n \n     // Apply styles multiple times with different delays to catch all rendering scenarios\n"
                },
                {
                    "date": 1762669037974,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -512,8 +512,36 @@\n \n function setFontSize(fontSize) {\n   rendition.themes.fontSize(`${fontSize}px`);\n   rendition.reportLocation();\n+  \n+  // Fix underlines after font size change (needs delay for re-rendering)\n+  setTimeout(function() {\n+    console.log('[EPUB] Re-fixing underlines after font size change...');\n+    for (var cfi in underlineAnnotations) {\n+      var annotation = underlineAnnotations[cfi];\n+      var style = underlineStyles[cfi];\n+      \n+      if (annotation && annotation.mark && annotation.mark.element) {\n+        var color = (style && style.color) || '#ff0000';\n+        var isDashed = (style && style.isDashed) || true;\n+        applyUnderlineStyles(annotation.mark.element, color, isDashed);\n+      }\n+    }\n+  }, 200);\n+  \n+  setTimeout(function() {\n+    for (var cfi in underlineAnnotations) {\n+      var annotation = underlineAnnotations[cfi];\n+      var style = underlineStyles[cfi];\n+      \n+      if (annotation && annotation.mark && annotation.mark.element) {\n+        var color = (style && style.color) || '#ff0000';\n+        var isDashed = (style && style.isDashed) || true;\n+        applyUnderlineStyles(annotation.mark.element, color, isDashed);\n+      }\n+    }\n+  }, 500);\n }\n \n //get current page text\n function getCurrentPageText() {\n"
                },
                {
                    "date": 1762669043726,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -512,29 +512,29 @@\n \n function setFontSize(fontSize) {\n   rendition.themes.fontSize(`${fontSize}px`);\n   rendition.reportLocation();\n-  \n+\n   // Fix underlines after font size change (needs delay for re-rendering)\n-  setTimeout(function() {\n+  setTimeout(function () {\n     console.log('[EPUB] Re-fixing underlines after font size change...');\n     for (var cfi in underlineAnnotations) {\n       var annotation = underlineAnnotations[cfi];\n       var style = underlineStyles[cfi];\n-      \n+\n       if (annotation && annotation.mark && annotation.mark.element) {\n         var color = (style && style.color) || '#ff0000';\n         var isDashed = (style && style.isDashed) || true;\n         applyUnderlineStyles(annotation.mark.element, color, isDashed);\n       }\n     }\n   }, 200);\n-  \n-  setTimeout(function() {\n+\n+  setTimeout(function () {\n     for (var cfi in underlineAnnotations) {\n       var annotation = underlineAnnotations[cfi];\n       var style = underlineStyles[cfi];\n-      \n+\n       if (annotation && annotation.mark && annotation.mark.element) {\n         var color = (style && style.color) || '#ff0000';\n         var isDashed = (style && style.isDashed) || true;\n         applyUnderlineStyles(annotation.mark.element, color, isDashed);\n"
                },
                {
                    "date": 1762669407267,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -380,12 +380,17 @@\n // Function to apply underline styles to an element\n function applyUnderlineStyles(element, color, isDashed) {\n   if (!element) return;\n \n-  // Remove all rect elements (we only want the line, not the box)\n+  // Make rect elements transparent but keep them for click area\n   var rects = element.querySelectorAll('rect');\n   rects.forEach(function (rect) {\n-    rect.remove();\n+    rect.setAttribute('stroke', 'none');\n+    rect.setAttribute('fill', 'none');\n+    rect.setAttribute('opacity', '0');\n+    rect.style.setProperty('stroke', 'none', 'important');\n+    rect.style.setProperty('fill', 'none', 'important');\n+    rect.style.setProperty('opacity', '0', 'important');\n   });\n \n   // Customize the line elements with !important styles\n   var lines = element.querySelectorAll('line');\n"
                },
                {
                    "date": 1762669850791,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,10 @@\n var chapters = []\n var clearSelectionOnPageChange = true; // Global flag for selection clearing behavior\n var underlineStyles = {}; // Store underline styles by CFI for re-rendering\n var underlineAnnotations = {}; // Store annotation objects by CFI for direct access\n+var lastClickedCfi = null; // Track last clicked CFI for debouncing\n+var lastClickTime = 0; // Track last click time\n \n \n \n function loadBook(data, cfi, manager, flow, spread, snap, allowScriptedContent, direction, useCustomSwipe, backgroundColor, foregroundColor, fontSize, clearSelectionOnNav) {\n@@ -430,8 +432,20 @@\n   console.log('[EPUB] addUnderLine called for CFI: ' + cfiString.substring(0, 30) + '...');\n \n   // Create the underline annotation with click handler\n   var annotation = rendition.annotations.underline(cfiString, {}, (e) => {\n+    // Prevent double-click: debounce clicks within 300ms\n+    var now = Date.now();\n+    if (lastClickedCfi === cfiString && (now - lastClickTime) < 300) {\n+      console.log('[EPUB] Debounced duplicate click on CFI: ' + cfiString.substring(0, 30) + '...');\n+      return;\n+    }\n+    \n+    lastClickedCfi = cfiString;\n+    lastClickTime = now;\n+    \n+    console.log('[EPUB] Annotation clicked: ' + cfiString.substring(0, 30) + '...');\n+    \n     // Notify Flutter when underline is clicked\n     window.flutter_inappwebview.callHandler('markClicked', cfiString);\n   }, \"ul\");\n \n"
                },
                {
                    "date": 1762669865422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,8 @@\n var chapters = []\n var clearSelectionOnPageChange = true; // Global flag for selection clearing behavior\n var underlineStyles = {}; // Store underline styles by CFI for re-rendering\n var underlineAnnotations = {}; // Store annotation objects by CFI for direct access\n-var lastClickedCfi = null; // Track last clicked CFI for debouncing\n-var lastClickTime = 0; // Track last click time\n \n \n \n function loadBook(data, cfi, manager, flow, spread, snap, allowScriptedContent, direction, useCustomSwipe, backgroundColor, foregroundColor, fontSize, clearSelectionOnNav) {\n@@ -432,20 +430,8 @@\n   console.log('[EPUB] addUnderLine called for CFI: ' + cfiString.substring(0, 30) + '...');\n \n   // Create the underline annotation with click handler\n   var annotation = rendition.annotations.underline(cfiString, {}, (e) => {\n-    // Prevent double-click: debounce clicks within 300ms\n-    var now = Date.now();\n-    if (lastClickedCfi === cfiString && (now - lastClickTime) < 300) {\n-      console.log('[EPUB] Debounced duplicate click on CFI: ' + cfiString.substring(0, 30) + '...');\n-      return;\n-    }\n-\n-    lastClickedCfi = cfiString;\n-    lastClickTime = now;\n-\n-    console.log('[EPUB] Annotation clicked: ' + cfiString.substring(0, 30) + '...');\n-\n     // Notify Flutter when underline is clicked\n     window.flutter_inappwebview.callHandler('markClicked', cfiString);\n   }, \"ul\");\n \n"
                }
            ],
            "date": 1762657250924,
            "name": "Commit-0",
            "content": "var book = ePub();\nvar rendition;\nvar displayed;\nvar chapters = []\nvar clearSelectionOnPageChange = true; // Global flag for selection clearing behavior\n\n\n\nfunction loadBook(data, cfi, manager, flow, spread, snap, allowScriptedContent, direction, useCustomSwipe, backgroundColor, foregroundColor, fontSize, clearSelectionOnNav) {\n  // Store the clearSelectionOnPageChange setting\n  clearSelectionOnPageChange = clearSelectionOnNav !== undefined ? clearSelectionOnNav : true;\n  var viewportHeight = window.innerHeight;\n  document.getElementById('viewer').style.height = viewportHeight;\n  var uint8Array = new Uint8Array(data)\n  book.open(uint8Array,)\n  rendition = book.renderTo(\"viewer\", {\n    manager: manager,\n    flow: flow,\n    // method: \"continuous\",\n    spread: spread,\n    width: \"100vw\",\n    height: \"100vh\",\n    snap: snap && !useCustomSwipe,\n    allowScriptedContent: allowScriptedContent,\n    defaultDirection: direction\n  });\n\n  if (cfi) {\n    displayed = rendition.display(cfi)\n  } else {\n    displayed = rendition.display()\n  }\n\n  rendition.on(\"displayed\", function (renderer) {\n    window.flutter_inappwebview.callHandler('displayed');\n  });\n\n  // Selection state tracking\n  var selectionTimeout = null;\n  var isSelecting = false;\n  var lastCfiRange = null;\n\n  // Handle selection clearing and changes\n  rendition.hooks.content.register(function (contents) {\n    contents.window.document.addEventListener('selectionchange', function () {\n      var selection = contents.window.getSelection();\n      var selectedText = selection.toString();\n\n      if (!selectedText) {\n        // Selection cleared\n        isSelecting = false;\n        lastCfiRange = null;\n        if (selectionTimeout) {\n          clearTimeout(selectionTimeout);\n          selectionTimeout = null;\n        }\n        window.flutter_inappwebview.callHandler('selectionCleared');\n      } else if (isSelecting) {\n        // Selection is being modified (dragging handles)\n        // Notify Flutter to hide the widget\n        window.flutter_inappwebview.callHandler('selectionChanging');\n\n        // Clear existing timeout\n        if (selectionTimeout) {\n          clearTimeout(selectionTimeout);\n        }\n\n        // Set timeout to detect when dragging stops\n        selectionTimeout = setTimeout(function () {\n          // Selection has stabilized, send the final selection\n          if (lastCfiRange) {\n            sendSelectionData(lastCfiRange, contents);\n          }\n          isSelecting = false;\n        }, 300); // 300ms debounce\n      }\n    });\n  });\n\n  book.loaded.navigation.then(function (toc) {\n    chapters = parseChapters(toc)\n    window.flutter_inappwebview.callHandler('chapters');\n  })\n\n  rendition.on(\"rendered\", function () {\n    window.flutter_inappwebview.callHandler('rendered');\n  })\n\n  // Function to calculate and send selection data\n  function sendSelectionData(cfiRange, contents) {\n    book.getRange(cfiRange).then(function (range) {\n      var selectedText = range.toString();\n\n      try {\n        // Get selection coordinates\n        var selection = contents.window.getSelection();\n        var rect = null;\n\n        if (selection && selection.rangeCount > 0) {\n          // Get the range and its client rect (relative to iframe viewport)\n          var selRange = selection.getRangeAt(0);\n          var clientRect = selRange.getBoundingClientRect();\n\n          // Get the WebView dimensions (parent window)\n          var webViewWidth = window.innerWidth;\n          var webViewHeight = window.innerHeight;\n\n          // Get the iframe element in the parent document\n          var iframe = contents.document.defaultView.frameElement;\n          var iframeRect = iframe.getBoundingClientRect();\n\n          // Calculate absolute position in WebView (iframe offset + selection position)\n          var absoluteLeft = iframeRect.left + clientRect.left;\n          var absoluteTop = iframeRect.top + clientRect.top;\n\n          // Normalize to 0-1 range relative to WebView dimensions\n          rect = {\n            left: absoluteLeft / webViewWidth,\n            top: absoluteTop / webViewHeight,\n            width: clientRect.width / webViewWidth,\n            height: clientRect.height / webViewHeight,\n            contentHeight: webViewHeight\n          };\n        }\n\n        var args = [cfiRange.toString(), selectedText, rect];\n        window.flutter_inappwebview.callHandler('selection', ...args);\n      } catch (e) {\n        // Still send the selection without coordinates if there's an error\n        var args = [cfiRange.toString(), selectedText, null];\n        window.flutter_inappwebview.callHandler('selection', ...args);\n      }\n    });\n  }\n\n  ///text selection callback\n  rendition.on(\"selected\", function (cfiRange, contents) {\n    lastCfiRange = cfiRange;\n\n    if (!isSelecting) {\n      // Initial selection - send immediately\n      isSelecting = true;\n      sendSelectionData(cfiRange, contents);\n    }\n    // If already selecting, the selectionchange handler will debounce it\n  });\n\n  //book location changes callback\n  rendition.on(\"relocated\", function (location) {\n    // Clear selection when navigating to a new page (if enabled)\n    if (clearSelectionOnPageChange && (isSelecting || lastCfiRange)) {\n      isSelecting = false;\n      lastCfiRange = null;\n      if (selectionTimeout) {\n        clearTimeout(selectionTimeout);\n        selectionTimeout = null;\n      }\n\n      // Clear the actual browser selection across all iframe contents\n      rendition.getContents().forEach(function (contents) {\n        try {\n          if (contents.window.getSelection) {\n            contents.window.getSelection().removeAllRanges();\n          }\n        } catch (e) {\n          // Ignore errors if iframe is not accessible\n        }\n      });\n\n      // Notify Flutter that selection was cleared\n      window.flutter_inappwebview.callHandler('selectionCleared');\n    }\n\n    var percent = location.start.percentage;\n    var location = {\n      startCfi: location.start.cfi,\n      endCfi: location.end.cfi,\n      progress: percent\n    }\n    var args = [location]\n    window.flutter_inappwebview.callHandler('relocated', ...args);\n  });\n\n  rendition.on('displayError', function (e) {\n    window.flutter_inappwebview.callHandler('displayError');\n  })\n\n  rendition.on('markClicked', function (cfiRange) {\n    var args = [cfiRange.toString()]\n    window.flutter_inappwebview.callHandler('markClicked', ...args);\n  })\n\n  book.ready.then(function () {\n    book.locations.generate(1600).then(() => {\n      if (cfi) {\n        rendition.display(cfi)\n      }\n      window.flutter_inappwebview.callHandler('locationLoaded');\n    })\n  })\n\n  rendition.hooks.content.register((contents) => {\n\n    if (useCustomSwipe) {\n      const el = contents.document.documentElement;\n\n      if (el) {\n        // console.log('EPUB_TEST_HOOK_IF')\n        detectSwipe(el, function (el, direction) {\n          // console.log(\"EPUB_TEST_DIR\"+direction.toString())\n\n          if (direction == 'l') {\n            rendition.next()\n          }\n          if (direction == 'r') {\n            rendition.prev()\n          }\n        });\n      }\n    }\n  });\n  rendition.themes.fontSize(fontSize + \"px\");\n  //set background and foreground color\n  updateTheme(backgroundColor, foregroundColor);\n}\n\nwindow.addEventListener(\"flutterInAppWebViewPlatformReady\", function (event) {\n  window.flutter_inappwebview.callHandler('readyToLoad');\n});\n\n//move to next page\nfunction next() {\n  rendition.next()\n}\n\n//move to previous page\nfunction previous() {\n  rendition.prev()\n}\n\n//move to given cfi location\nfunction toCfi(cfi) {\n  rendition.display(cfi)\n}\n\n//get all chapters\nfunction getChapters() {\n  return chapters;\n}\n\nasync function getBookInfo() {\n  const metadata = book.package.metadata;\n  metadata['coverImage'] = book.cover;\n  console.log(\"getBookInfo\", await book.coverUrl());\n  return metadata;\n}\n\nfunction getCurrentLocation() {\n  var percent = rendition.location.start.percentage;\n  // var percentage = Math.floor(percent * 100);\n  var location = {\n    startCfi: rendition.location.start.cfi,\n    endCfi: rendition.location.end.cfi,\n    progress: percent\n  }\n  return location;\n}\n\n///parsing chapters and subitems recursively\nvar parseChapters = function (toc) {\n  var chapters = []\n  toc.forEach(function (chapter) {\n    chapters.push({\n      title: chapter.label,\n      href: chapter.href,\n      id: chapter.id,\n      subitems: parseChapters(chapter.subitems)\n    })\n  })\n  return chapters;\n}\n\nfunction searchInBook(query) {\n  search(query).then(function (data) {\n    var args = [data]\n    window.flutter_inappwebview.callHandler('search', ...args);\n  })\n}\n\n\n// adds highlight with given color\nfunction addHighlight(cfiRange, color, opacity) {\n  rendition.annotations.highlight(cfiRange, {}, (e) => {\n    // console.log(\"highlight clicked\", e.target);\n  }, \"hl\", { \"fill\": color, \"fill-opacity\": '0.3', \"mix-blend-mode\": \"multiply\" });\n}\n\n// adds underline with optional color and style (solid/dashed)\nfunction addUnderLine(cfiString, color, isDashed) {\n  var styles = { \"stroke\": color || \"black\" };\n\n  // Add dash style if requested\n  if (isDashed) {\n    styles[\"stroke-dasharray\"] = \"5,3\"; // 5px dash, 3px gap\n  }\n\n  rendition.annotations.underline(cfiString, {}, (e) => {\n    // console.log(\"underline clicked\", e.target);\n  }, \"ul\", styles);\n}\n\nfunction addMark(cfiString) {\n  rendition.annotations.mark(cfiString)\n}\n\nfunction removeHighlight(cfiString) {\n  rendition.annotations.remove(cfiString, \"highlight\");\n}\n\nfunction removeUnderLine(cfiString) {\n  rendition.annotations.remove(cfiString, \"underline\");\n}\n\nfunction removeMark(cfiString) {\n  rendition.annotations.remove(cfiString, \"mark\");\n}\n\nfunction toProgress(progress) {\n  var cfi = book.locations.cfiFromPercentage(progress);\n  rendition.display(cfi);\n}\n\n\nfunction search(q) {\n  return Promise.all(\n    book.spine.spineItems.map(item => item.load(book.load.bind(book)).then(item.find.bind(item, q)).finally(item.unload.bind(item)))\n  ).then(results => Promise.resolve([].concat.apply([], results)));\n};\n\nfunction setFontSize(fontSize) {\n  rendition.themes.default({\n    p: {\n      // \"margin\": '10px',\n      \"font-size\": `${fontSize}px`\n    }\n  });\n}\n\nfunction setSpread(spread) {\n  rendition.spread(spread);\n}\n\nfunction setFlow(flow) {\n  rendition.flow(flow);\n}\n\nfunction setManager(manager) {\n  rendition.manager(manager);\n}\n\nfunction setFontSize(fontSize) {\n  rendition.themes.fontSize(`${fontSize}px`);\n  rendition.reportLocation();\n}\n\n//get current page text\nfunction getCurrentPageText() {\n  var startCfi = rendition.location.start.cfi\n  var endCfi = rendition.location.end.cfi\n  var cfiRange = makeRangeCfi(startCfi, endCfi)\n  book.getRange(cfiRange).then(function (range) {\n    var text = range.toString();\n    var args = [text, cfiRange]\n    window.flutter_inappwebview.callHandler('epubText', ...args);\n  })\n}\n\n//get text from a range\nfunction getTextFromCfi(startCfi, endCfi) {\n  var cfiRange = makeRangeCfi(startCfi, endCfi)\n  book.getRange(cfiRange).then(function (range) {\n    var text = range.toString();\n    var args = [text, cfiRange]\n    window.flutter_inappwebview.callHandler('epubText', ...args);\n  })\n}\n\n///update theme\nfunction updateTheme(backgroundColor, foregroundColor) {\n  if (backgroundColor && foregroundColor) {\n    rendition.themes.register(\"dark\", { \"body\": { \"background\": backgroundColor, \"color\": foregroundColor } });\n    rendition.themes.select(\"dark\");\n  }\n}\n\nconst makeRangeCfi = (a, b) => {\n  const CFI = new ePub.CFI()\n  const start = CFI.parse(a), end = CFI.parse(b)\n  const cfi = {\n    range: true,\n    base: start.base,\n    path: {\n      steps: [],\n      terminal: null\n    },\n    start: start.path,\n    end: end.path\n  }\n  const len = cfi.start.steps.length\n  for (let i = 0; i < len; i++) {\n    if (CFI.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n      if (i == len - 1) {\n        // Last step is equal, check terminals\n        if (cfi.start.terminal === cfi.end.terminal) {\n          // CFI's are equal\n          cfi.path.steps.push(cfi.start.steps[i])\n          // Not a range\n          cfi.range = false\n        }\n      } else cfi.path.steps.push(cfi.start.steps[i])\n    } else break\n  }\n  cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length)\n  cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length)\n\n  return 'epubcfi(' + CFI.segmentString(cfi.base)\n    + '!' + CFI.segmentString(cfi.path)\n    + ',' + CFI.segmentString(cfi.start)\n    + ',' + CFI.segmentString(cfi.end)\n    + ')'\n}\n\nfunction detectSwipe(el, func) {\n  swipe_det = new Object();\n  swipe_det.sX = 0;\n  swipe_det.sY = 0;\n  swipe_det.eX = 0;\n  swipe_det.eY = 0;\n  var min_x = 50;  //min x swipe for horizontal swipe\n  var max_x = 40;  //max x difference for vertical swipe\n  var min_y = 40;  //min y swipe for vertical swipe\n  var max_y = 50;  //max y difference for horizontal swipe\n  var direc = \"\";\n  ele = el\n  ele.addEventListener('touchstart', function (e) {\n    var t = e.touches[0];\n    swipe_det.sX = t.screenX;\n    swipe_det.sY = t.screenY;\n  }, false);\n  ele.addEventListener('touchmove', function (e) {\n    e.preventDefault();\n    var t = e.touches[0];\n    swipe_det.eX = t.screenX;\n    swipe_det.eY = t.screenY;\n  }, false);\n  ele.addEventListener('touchend', function (e) {\n    //horizontal detection\n    if ((((swipe_det.eX - min_x > swipe_det.sX) || (swipe_det.eX + min_x < swipe_det.sX)) && ((swipe_det.eY < swipe_det.sY + max_y) && (swipe_det.sY > swipe_det.eY - max_y)))) {\n      if (swipe_det.eX > swipe_det.sX) direc = \"r\";\n      else direc = \"l\";\n    }\n    //vertical detection\n    if ((((swipe_det.eY - min_y > swipe_det.sY) || (swipe_det.eY + min_y < swipe_det.sY)) && ((swipe_det.eX < swipe_det.sX + max_x) && (swipe_det.sX > swipe_det.eX - max_x)))) {\n      if (swipe_det.eY > swipe_det.sY) direc = \"d\";\n      else direc = \"u\";\n    }\n\n    if (direc != \"\") {\n      if (typeof func == 'function') func(el, direc);\n    }\n    direc = \"\";\n  }, false);\n}"
        }
    ]
}